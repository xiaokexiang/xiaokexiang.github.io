<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>ReentrantLock源码解析</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Lock与Synchronized都是可重入锁，否则会发生死锁。Lock锁核心在于AbstractQueueSynchronizer，又名队列同步器(简称AQS)。如果需要实现自定义锁，除了需要实现Lock接口外，还需要内部类继承Sync类。
AbstractQueueSynchronizer 记录当前锁的持有线程 由AQS的父类AbstractOwnableSynchronizer实现记录当前锁的持有线程功能（独占锁）。
state变量 内部维护了volatile修饰的state变量，state = 0时表明没有线程获取锁，state = 1时表明有一个线程获取锁，当state &amp;gt; 1时，说明该线程重入了该锁。
线程阻塞和唤醒 由LockSupport类实现，其底层是调用了Unsafe的park 和 unpark。如果当前线程是非中断状态，调用park()阻塞，返回中断状态是false，如果当前线程是中断状态，调用park()会不起作用立即返回。也是为什么AQS要清空中断状态的原因。
FIFO队列 AQS内部维护了一个基于CLH(Craig, Landin, and Hagersten(CLH)locks。基于链表的公平的自旋锁)变种的FIFO双向链表阻塞队列，在等待机制上由自旋改成阻塞唤醒(park/unpark)。
 还未初始化的时候，head = tail = null，之后初始化队列，往其中假如阻塞的线程时，会新建一个空的node，让head和tail都指向这个空node。之后加入被阻塞的线程对象。当head=tai时候说明队列为空。
 Node的waitStatus    Node状态 描述     INIT=0 Node初始创建时默认为0   CANCELLED=1 由于超时或者中断，线程获取锁的请求取消了，节点一旦变成此状态就不会再变化。   SIGNAL=-1 表示线程已经准备好了，等待资源释放去获取锁。   CONDITION=-2 表示节点处于等待队列中，等待被唤醒。   PROPAGATE=-3 只有当前线程处于SHARED情况下，该字段才会使用，用于共享锁的获取。     ReentrentLock 我们选择ReentrentLock作为入口进行源码解读，自定义的获取释放锁的方法，由其内部抽象类Sync的子类FairSync和NonfairSync中的tryAcquire、tryRelease实现。
class Test { private static final ReentrantLock LOCK = new ReentrantLock(); public void run() { LOCK."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<meta name="google-site-verification" content="e1ELBPEvOV5kwQNtzaLcNt-3iZy83eiNhSZkHhQPecs" />
<meta name="baidu-site-verification" content="aNoX6MUEHW" />


<link rel="canonical" href="https://leejay.top/post/reentrantlock/" />

<script type="text/javascript"
        async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
        >
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] },
    'HTML-CSS': {
        showMathMenu: false 
    }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>




<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<link rel="stylesheet" href="https://leejay.top/assets/style.css">




<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://leejay.top/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="https://leejay.top/img/favicon.png">



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ReentrantLock源码解析"/>
<meta name="twitter:description" content="AbstractQueueSynchronizer是一种同步框架，而ReentrantLock是基于它实现的`可重入独占锁`，具有公平/非公平两种实现。"/>



<meta property="og:title" content="ReentrantLock源码解析" />
<meta property="og:description" content="AbstractQueueSynchronizer是一种同步框架，而ReentrantLock是基于它实现的`可重入独占锁`，具有公平/非公平两种实现。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leejay.top/post/reentrantlock/" />
<meta property="article:published_time" content="2020-06-15T15:53:46+08:00" />
<meta property="article:modified_time" content="2020-06-15T15:53:46+08:00" /><meta property="og:site_name" content="Aurora" />






  </head>
  <body class="">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="https://leejay.top" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="https://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg></span>
    <span class="logo__text">Aurora</span>
    <span class="logo__cursor"></span>
    <span class="logo__cursor2"></span>
  
</a>
    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/categories">Categories</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/categories">Categories</a></li>
      
    
      
        <li><a href="/tags">Tags</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="https://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title"><a href="https://leejay.top/post/reentrantlock/">ReentrantLock源码解析</a></h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-06-15
        </span>

        
          
        
      

      
      
    </div>

    
      <span class="post-tags">
        
        <i class="fa fa-hashtag"></i><a href="https://leejay.top/tags/reentrantlock/">ReentrantLock </a>&nbsp;
        
        <i class="fa fa-hashtag"></i><a href="https://leejay.top/tags/aqs/">AQS</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      
      <p>Lock与Synchronized都是<code>可重入锁</code>，否则会发生死锁。Lock锁核心在于<code>AbstractQueueSynchronizer</code>，又名<code>队列同步器(简称AQS)</code>。如果需要实现自定义锁，除了需要实现Lock接口外，还需要内部类继承Sync类。</p>
<h3 id="abstractqueuesynchronizer">AbstractQueueSynchronizer</h3>
<p><img src="https://image.leejay.top/image/20200608/GVtL7ztzwtCl.png?imageslim" alt=""></p>
<h4 id="记录当前锁的持有线程">记录当前锁的持有线程</h4>
<p>由AQS的父类<code>AbstractOwnableSynchronizer</code>实现记录当前锁的持有线程功能（独占锁）。</p>
<h4 id="state变量">state变量</h4>
<p>内部维护了volatile修饰的state变量，state = 0时表明没有线程获取锁，state = 1时表明有一个线程获取锁，当state &gt; 1时，说明该线程重入了该锁。</p>
<h4 id="线程阻塞和唤醒">线程阻塞和唤醒</h4>
<p>由<code>LockSupport</code>类实现，其底层是调用了Unsafe的park 和 unpark。<code>如果当前线程是非中断状态，调用park()阻塞，返回中断状态是false，如果当前线程是中断状态，调用park()会不起作用立即返回。也是为什么AQS要清空中断状态的原因</code>。</p>
<h4 id="fifo队列">FIFO队列</h4>
<p>AQS内部维护了一个基于<code>CLH(Craig, Landin, and Hagersten(CLH)locks。基于链表的公平的自旋锁)</code>变种的FIFO双向链表阻塞队列，在等待机制上由自旋改成阻塞唤醒(park/unpark)。</p>
<p><img src="https://image.leejay.top/image/20200609/CHJldTlsLVp2.png?imageslim" alt=""></p>
<blockquote>
<p>还未初始化的时候，head = tail = null，之后初始化队列，往其中假如阻塞的线程时，会新建一个空的node，让head和tail都指向这个空node。之后加入被阻塞的线程对象。当head=tai时候说明队列为空。</p>
</blockquote>
<h4 id="node的waitstatus">Node的waitStatus</h4>
<table>
<thead>
<tr>
<th style="text-align:left">Node状态</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">INIT=0</td>
<td style="text-align:left">Node初始创建时默认为0</td>
</tr>
<tr>
<td style="text-align:left">CANCELLED=1</td>
<td style="text-align:left">由于超时或者中断，线程获取锁的请求取消了，节点一旦变成此状态就不会再变化。</td>
</tr>
<tr>
<td style="text-align:left">SIGNAL=-1</td>
<td style="text-align:left">表示线程已经准备好了，等待资源释放去获取锁。</td>
</tr>
<tr>
<td style="text-align:left">CONDITION=-2</td>
<td style="text-align:left">表示节点处于等待队列中，等待被唤醒。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATE=-3</td>
<td style="text-align:left">只有当前线程处于SHARED情况下，该字段才会使用，用于共享锁的获取。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="reentrentlock">ReentrentLock</h3>
<p>我们选择<code>ReentrentLock</code>作为入口进行源码解读，自定义的获取释放锁的方法，由其内部抽象类Sync的子类FairSync和NonfairSync中的tryAcquire、tryRelease实现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ReentrantLock LOCK <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock<span style="color:#f92672">();</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        LOCK<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//dosomething
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
            LOCK<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>  
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>判断是否成功获取锁的标志，就是CAS修改volatile修饰的state变量是否成功。</p>
</blockquote>
<h3 id="公平锁和非公平锁">公平锁和非公平锁</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 非公平锁实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NonfairSync</span> <span style="color:#66d9ef">extends</span> Sync <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 先尝试CAS获取锁
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">))</span>
            setExclusiveOwnerThread<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">else</span>
            <span style="color:#75715e">// 再排队
</span><span style="color:#75715e"></span>            acquire<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 公平锁实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FairSync</span> <span style="color:#66d9ef">extends</span> Sync <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> serialVersionUID <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>3000897897090466540L<span style="color:#f92672">;</span>
	<span style="color:#75715e">// 去排队
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        acquire<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>公平锁和非公平锁如何选择？</p>
<p>非公平锁一进来就尝试去获取锁，有效的减少了线程的上下文切换，所以为了追求<code>高吞吐量</code>建议选择非公平锁，但是会导致某些线程长时间在排队，没有机会获取锁。否则建议选择公平锁。</p>
</blockquote>
<h3 id="acquire">acquire</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 如果第一次获取锁失败，说明此时有其他线程持有锁，所以执行acquire
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
        acquireQueued<span style="color:#f92672">(</span>addWaiter<span style="color:#f92672">(</span>Node<span style="color:#f92672">.</span><span style="color:#a6e22e">EXCLUSIVE</span><span style="color:#f92672">),</span> arg<span style="color:#f92672">))</span>
        selfInterrupt<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="tryacquire">tryAcquire</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 调用非公平锁的tryAcquire，再一次尝试去获取锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> nonfairTryAcquire<span style="color:#f92672">(</span>acquires<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 返回false表明没有获取到锁，true表明成功获取锁/重入锁
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">nonfairTryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 获取当前线程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> Thread current <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
    <span style="color:#75715e">// 获取state状态
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 如果state是0，表明当前没有线程获取锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 尝试去获取锁，获取成功就设置独占线程为当前线程
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> acquires<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            setExclusiveOwnerThread<span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 如果当前线程已经是独占线程，此时说明锁重入了
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> getExclusiveOwnerThread<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 修改state的值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c <span style="color:#f92672">+</span> acquires<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextc <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">// 设置state值，因为此时的获取锁的线程就是当前线程
</span><span style="color:#75715e"></span>        setState<span style="color:#f92672">(</span>nextc<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 公平锁的tryAcquire实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> acquires<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">...</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// hasQueuedPredecessors是公平锁的主要体现
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasQueuedPredecessors<span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span>
                compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> acquires<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                setExclusiveOwnerThread<span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>Q:  为什么有的地方使用setState()，有的地方使用CAS？</p>
<p>A:  因为使用setState()方法的前提是已经获取了锁，使用了CAS的是因为此时还没有获取锁。</p>
</blockquote>
<h4 id="hasqueuedpredecessors">hasQueuedPredecessors</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// true/false 有节点在等待/无节点等待
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasQueuedPredecessors</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 这里为什么tail获取在head之前？
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 假设第一个节点入队，根据enq()设置head和tail可知
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果此处tail = null，head = null | head != null都有可能
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果此处tail != null ，那么(head = tail) != null
</span><span style="color:#75715e"></span>    Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
    Node h <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
    Node s<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">!=</span> t <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#75715e">// (s = h.next) == null 成立说明有其他线程正在初始化队列
</span><span style="color:#75715e"></span>        <span style="color:#f92672">((</span>s <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">!=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">());</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>返回情况分析：</p>
<ol>
<li>
<p>若<code>h == t</code>说明此时队列还没有初始化或只有哨兵节点，返回false表明无等待节点。</p>
</li>
<li>
<p>若<code>h != t</code>成立，说明此时队列有节点啊，那<code>((s = h.next) == null)</code>应该也成立啊？
其实不然，我们假设线程A获取锁失败，尝试加入队列，此时队列还未初始化，A执行到enq方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enq</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
        Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 线程A准备初始化队列，它setHead(new Node())成功了
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 此时线程切换，线程B执行了hasQueuedPredecessors()
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 此时 head != null; tail = null; head.next = null
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 此时h != t 且 (s = h.next) = null
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetHead<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">()))</span>
                tail <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetTail<span style="color:#f92672">(</span>t<span style="color:#f92672">,</span> node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                t<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p>若<code>((s = h.next) == null)</code>成立，说明此时存在另一个线程执行到<code>compareAndSetHead(new Node())</code>和<code>tail = head</code>的中间状态。所以也需要返回true，表明有节点在等待。</p>
</li>
<li>
<p>若<code>((s = h.next) == null)</code>不成立，我们继续判断队列中第一个等待线程（<code>s.thread != Thread.currentThread()</code>）是否是当前线程，是就返回true，否则返回false。</p>
</li>
<li>
<p>方法中为什么<code>Node t = tail</code>获取在<code>Node h = head</code>之前？
根据上面的分析，我们知道第一个节点入队的时候会出现<code>head != null 但 tail = null</code>的情况，因为是<code>先设置head再设置tail</code>，操作非原子性。
我们假设<code>队列未初始化</code>，hasQueuedPredecessors方法中<code>tail和head代码位置互换</code>，线程A先执行<code>Node h = head;</code>此时<code>head = null</code>，线程切换，线程B执行enq方法初始化队列导致<code>（head = tail）!= null</code>，又切回线程A，执行<code>Node t = tail</code>，<code>tail != null</code>，判断代码<code>h != t</code>成立，继续判断<code>(s = h.next) == null</code>出问题了，<code>h =null,h.next会抛空指针!!!</code>，这就是问题所在。(再次膜拜Doug lea！！！)</p>
</li>
</ol>
</blockquote>
<h4 id="addwaiter">addWaiter</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 获取不到锁，将当前线程构建成node对象加入队列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">addWaiter</span><span style="color:#f92672">(</span>Node mode<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 创建node对象(currentThread, Node.EXCLUSIVE)
</span><span style="color:#75715e"></span>    Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">(),</span> mode<span style="color:#f92672">);</span>
    Node pred <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果尾节点不等于null，说明队列不为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pred <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 设置node的prev为尾节点
</span><span style="color:#75715e"></span>        node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果此时有两个线程尝试用将node设置为tail尾节点
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 所以需要CAS保证只有一个设置成功，另一个执行下面的enq()加入队列
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetTail<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 设置成功后，添加next指针指向node
</span><span style="color:#75715e"></span>            pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 尾节点为null 或 插入尾节点失败
</span><span style="color:#75715e"></span>    enq<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 循环执行插入操作，直到插入队尾成功
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enq</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
        Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果尾节点是null，说明队列还没有初始化
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 将head设置成空node，并且tail=head(说明此时队列初始化了但还没有节点)
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetHead<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Node<span style="color:#f92672">()))</span>
                tail <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// t!=null，设置node.prev=t
</span><span style="color:#75715e"></span>            node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
            <span style="color:#75715e">// CAS设置node到队尾，如果不成功继续循环获取tail直到设置成功
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetTail<span style="color:#f92672">(</span>t<span style="color:#f92672">,</span> node<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// CAS成功，设置t的next属性
</span><span style="color:#75715e"></span>                t<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
                <span style="color:#75715e">// 跳出循环返回node的前驱节点
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="acquirequeued">acquireQueued</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 至此node已经插入队列成功，并返回
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">acquireQueued</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> Node node<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 获取node的前继节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">predecessor</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">// 如果node的前继节点是头节点，则node尝试去获取锁
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// tryAcquire(arg)会抛出异常
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// 获取锁成功，设置头节点为node，并清空thread和prev属性
</span><span style="color:#75715e"></span>                setHead<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
                <span style="color:#75715e">// 方便回收前继节点p
</span><span style="color:#75715e"></span>                p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 修改failed参数
</span><span style="color:#75715e"></span>                failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
                <span style="color:#75715e">// 跳出循环并返回
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> interrupted<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 如果前继节点不是head节点 或 前继节点是head节点但获取不到锁
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 判断是否需要挂起,如果阻塞节点被唤醒，还会继续循环获取，直到获取锁才return
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shouldParkAfterFailedAcquire<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
                parkAndCheckInterrupt<span style="color:#f92672">())</span>
                interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 如果跳出循环，failed=false，不跳出循环也不会执行到这里
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 也就是只有tryAcquire(arg)发生异常了才会执行cancelAcquire()
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>failed<span style="color:#f92672">)</span>
            cancelAcquire<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> Node <span style="color:#a6e22e">predecessor</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> NullPointerException <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 获取node的prev节点p
</span><span style="color:#75715e"></span>    Node p <span style="color:#f92672">=</span> prev<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果p为null则抛出异常，这里的空指针一般不会生效，只是为了帮助虚拟机
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">else</span>
    <span style="color:#75715e">// 否则返回前继节点p
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> p<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 将node节点设置为head头节点，获取锁之后都会将头节点相关信息清除
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHead</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    head <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    node<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 判断获取锁失败之后是否需要park
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">shouldParkAfterFailedAcquire</span><span style="color:#f92672">(</span>Node pred<span style="color:#f92672">,</span> Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 获取node前继节点的waitStatus，默认情况下值为0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果是signal，说明前继节点已经准备就绪，等待被占用的资源释放
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">==</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果前继节点waitStatus&gt;0，说明是Cancel
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 获取前继节点的前继节点，直到它的状态&gt;0(直到前继节点不是cancel节点)
</span><span style="color:#75715e"></span>            node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pred<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 将不是cancel的节点与node相连
</span><span style="color:#75715e"></span>        pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 尝试将前继节点pred设置成signal状态，设置signal的作用是什么？
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 在解锁的时候只有head!=null且为signal状态才会唤醒head的下个节点
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果pred状态设置成功，第二次就会进入ws == Node.SIGNAL，返回true
</span><span style="color:#75715e"></span>        compareAndSetWaitStatus<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> ws<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// 将线程挂起并检查是否被中断
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parkAndCheckInterrupt</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 挂机当前线程，不会往下执行了
</span><span style="color:#75715e"></span>    LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">park</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 往下执行的条件: unpark(t)或被中断
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 返回中断状态(并清空中断状态)
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>LockSupport.park()除了<code>能够被unpark()唤醒，还会响应interrupt()打断</code>，但是Lock锁不能响应中断，如果是unpark，会返回false，如果是interrupt则返回true。</p>
</blockquote>
<h4 id="cancelacquire">cancelAcquire</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 节点取消获取锁
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cancelAcquire</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">// 忽略不存在的node
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
          <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
  	<span style="color:#75715e">// 清空node的thread属性
</span><span style="color:#75715e"></span>      node<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
  
      <span style="color:#75715e">// 获取node的不是cancel的前继节点
</span><span style="color:#75715e"></span>      Node pred <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">;</span>
      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pred<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
          node<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">;</span>
  
      <span style="color:#75715e">// 获取有效前继节点的后继节点
</span><span style="color:#75715e"></span>      Node predNext <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
  
      <span style="color:#75715e">// 设置node节点为cancel状态
</span><span style="color:#75715e"></span>      node<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">CANCELLED</span><span style="color:#f92672">;</span>
  
      <span style="color:#75715e">// 如果node是tail尾节点，将pred(非cancel节点)设置为尾节点
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>node <span style="color:#f92672">==</span> tail <span style="color:#f92672">&amp;&amp;</span> compareAndSetTail<span style="color:#f92672">(</span>node<span style="color:#f92672">,</span> pred<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">// 设置尾节点pred的next指针为null
</span><span style="color:#75715e"></span>          compareAndSetNext<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> predNext<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">int</span> ws<span style="color:#f92672">;</span>
          <span style="color:#75715e">// 如果node不是tail尾节点
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// 1.pred不是头节点
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pred <span style="color:#f92672">!=</span> head <span style="color:#f92672">&amp;&amp;</span>
              <span style="color:#75715e">// 2.如果不是则判断前继节点状态是否是signal
</span><span style="color:#75715e"></span>              <span style="color:#f92672">((</span>ws <span style="color:#f92672">=</span> pred<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span> <span style="color:#f92672">||</span>
               <span style="color:#75715e">// 3.如果不是signal则尝试将pred前继节点设置为signal
</span><span style="color:#75715e"></span>               <span style="color:#f92672">(</span>ws <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> compareAndSetWaitStatus<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> ws<span style="color:#f92672">,</span> Node<span style="color:#f92672">.</span><span style="color:#a6e22e">SIGNAL</span><span style="color:#f92672">)))</span> <span style="color:#f92672">&amp;&amp;</span>
              <span style="color:#75715e">// 4.判断前继节点线程信息是否为null
</span><span style="color:#75715e"></span>              pred<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">// 1，2/3，4条件满足，获取node的后继节点
</span><span style="color:#75715e"></span>              Node next <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
              <span style="color:#75715e">// 如果后继节点不为null且waitStatus&lt;=0
</span><span style="color:#75715e"></span>              <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> next<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                  <span style="color:#75715e">// 将node的前继节点的后继节点改成node的后继节点
</span><span style="color:#75715e"></span>                  compareAndSetNext<span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> predNext<span style="color:#f92672">,</span> next<span style="color:#f92672">);</span>
          <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
              <span style="color:#75715e">// 如果node前继不是head &amp; 也不是tail
</span><span style="color:#75715e"></span>              unparkSuccessor<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
          <span style="color:#f92672">}</span>
  		<span style="color:#75715e">// 将node的后继节点设置为自身，方便回收
</span><span style="color:#75715e"></span>          node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 唤醒head节点后不为cancel的非null节点
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unparkSuccessor</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span><span style="color:#f92672">;</span>
      <span style="color:#75715e">// 如果node.waitStatus &lt; 0 ，将其设置为0(初始状态)
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ws <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
          compareAndSetWaitStatus<span style="color:#f92672">(</span>node<span style="color:#f92672">,</span> ws<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
  	<span style="color:#75715e">// 获取node的后继节点
</span><span style="color:#75715e"></span>      Node s <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
      <span style="color:#75715e">// 如果后继节点为null或是cancel，循环查找直到不符合该条件的node
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          s <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
          <span style="color:#75715e">// 重点：从队尾往前找！！！！
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node t <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span> t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> t <span style="color:#f92672">!=</span> node<span style="color:#f92672">;</span> t <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span><span style="color:#f92672">)</span>
              <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
                  s <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
      <span style="color:#75715e">// 找到不为cancel的非null节点
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
          <span style="color:#75715e">// 唤醒对应的线程
</span><span style="color:#75715e"></span>          LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">unpark</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>Q：为什么AQS的队列查找中，是从队列尾从后向前查找的？</p>
<p>A：节点入队时，都是遵循如下范式设置tail节点：</p>
<p><code>① node.prev = tail; </code></p>
<p><code>② if(compareAndSetTail(tail, node)) { </code></p>
<p><code>			③ tail.next = node; }</code></p>
<p>②和③两行代码不是原子性的，所以就存在：线程A将nodeA成功设置为tail尾节点，如果此时线程切换，线程B执行unparkSuccessor方法唤醒尾节点，如果从前往后查询，会发现<code>tail.next = null</code>，会认为tail是尾节点，其实此时的尾节点已经被线程A改成了nodeA，doug lea在AQS的文档中也说明了<code>prev是务必要保证的可靠引用，而next只是一种优化。</code></p>
<p>又比如cancelAcquire方法中，都是断开了next指针，prev指针没有断开，也是上诉理论的一种体现。</p>
</blockquote>
<h4 id="selfinterrupt">selfInterrupt</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 当获取锁或插入node到队列的过程中发生了interrupt，那么这里需要补上打断
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selfInterrupt</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">interrupt</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="独占锁获取执行流程">独占锁获取执行流程</h3>
<p><img src="https://image.leejay.top/image/20200628/9RLQ683DruWq.png?imageslim" alt=""></p>
<h3 id="unlock">unlock</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 尝试释放锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tryRelease<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        Node h <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        <span style="color:#75715e">// 如果头节点不为null且不是初始状态
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h<span style="color:#f92672">.</span><span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span>
            <span style="color:#75715e">// 唤醒头节点的后继节点
</span><span style="color:#75715e"></span>            unparkSuccessor<span style="color:#f92672">(</span>h<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 唤醒的线程会重新从parkAndCheckInterrupt()方法中被unpark
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 然后继续新一轮的获取锁或者获取不到锁park的流程
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> releases<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 此时处于已获取锁状态，所以不需要cas获取state，这里也会处理多次重入的情况
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState<span style="color:#f92672">()</span> <span style="color:#f92672">-</span> releases<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果当前线程不是独占线程抛异常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> getExclusiveOwnerThread<span style="color:#f92672">())</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalMonitorStateException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">boolean</span> free <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 如果state=0说明独占锁或锁重入释放准备完毕
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        free <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        setExclusiveOwnerThread<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 设置状态为0
</span><span style="color:#75715e"></span>    setState<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
    <span style="color:#75715e">// 释放锁成功
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> free<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="lockinterruptibly">lockInterruptibly</h3>
<p>可及时响应线程中断的获取锁的API</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 方法入口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lockInterruptibly</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
  sync<span style="color:#f92672">.</span><span style="color:#a6e22e">acquireInterruptibly</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 可响应中断
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquireInterruptibly</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 如果线程被打断直接抛出异常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 尝试去获取锁，获取失败将node加入队列，被中断抛出异常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span>
        doAcquireInterruptibly<span style="color:#f92672">(</span>arg<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 与acquireQueue几乎相同
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doAcquireInterruptibly</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">)</span>
    <span style="color:#f92672">...</span>
    	<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shouldParkAfterFailedAcquire<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
        	parkAndCheckInterrupt<span style="color:#f92672">())</span>
            <span style="color:#75715e">// 与acquireQueue唯一的区别
</span><span style="color:#75715e"></span>        	<span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="trylocktime">tryLock(time)</h3>
<p>响应中断且非阻塞，指定时间内获取不到锁就返回。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> sync<span style="color:#f92672">.</span><span style="color:#a6e22e">tryAcquireNanos</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> unit<span style="color:#f92672">.</span><span style="color:#a6e22e">toNanos</span><span style="color:#f92672">(</span>timeout<span style="color:#f92672">));</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 与lockInterruptibly相同抛出中断异常切换尝试获取锁，获取锁过程中响应中断
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquireNanos</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> nanosTimeout<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
    <span style="color:#75715e">// 如果获取锁失败就去执行doAcquireNanos，直到超时返回false
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
        doAcquireNanos<span style="color:#f92672">(</span>arg<span style="color:#f92672">,</span> nanosTimeout<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 获取锁的超时方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">doAcquireNanos</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arg<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> nanosTimeout<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nanosTimeout <span style="color:#f92672">&lt;=</span> 0L<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 计算deadline
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> deadline <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">nanoTime</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> nanosTimeout<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 将node添加到队列中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> Node node <span style="color:#f92672">=</span> addWaiter<span style="color:#f92672">(</span>Node<span style="color:#f92672">.</span><span style="color:#a6e22e">EXCLUSIVE</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">predecessor</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                setHead<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
                p<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// help GC
</span><span style="color:#75715e"></span>                failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 计算剩余时间
</span><span style="color:#75715e"></span>            nanosTimeout <span style="color:#f92672">=</span> deadline <span style="color:#f92672">-</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">nanoTime</span><span style="color:#f92672">();</span>
            <span style="color:#75715e">// 如果小于0说明计时结束，获取失败
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nanosTimeout <span style="color:#f92672">&lt;=</span> 0L<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 判断是否需要阻塞，区别在于该方法阻塞了指定了时长
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 为什么剩余时间要大于spinForTimeoutThreshold(1000)才会阻塞
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 说明此时剩余时间非常短，没必要再执行挂起操作了，不如直接执行下一次循环
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>shouldParkAfterFailedAcquire<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span>
                nanosTimeout <span style="color:#f92672">&gt;</span> spinForTimeoutThreshold<span style="color:#f92672">)</span>
                <span style="color:#75715e">// 调用lockSupport park指定时长
</span><span style="color:#75715e"></span>                LockSupport<span style="color:#f92672">.</span><span style="color:#a6e22e">parkNanos</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> nanosTimeout<span style="color:#f92672">);</span>
            <span style="color:#75715e">// park过程中被中断直接抛出异常
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">())</span>
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>failed<span style="color:#f92672">)</span>
            cancelAcquire<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>相比lockInterruptibly方法，tryLock(time)除了响应中断外，还拥有超时控制，由LockSupport.parkNanos()实现。</p>
</blockquote>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h">其他文章</span>
            <hr />
          </div>
          <div class="pagination__buttons">
            
              <span class="button previous">
                <a href="https://leejay.top/post/condition/">
                  <span class="button__icon">←</span>
                  <span class="button__text">Condition源码解析</span>
                </a>
              </span>
            
            
              <span class="button next">
                <a href="https://leejay.top/post/cas/">
                  <span class="button__text">CAS乐观锁浅析</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    


    
      
        

      
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">苏ICP备18050258号</div>
    
  </div>
</footer>

<script src="https://leejay.top/assets/main.js"></script>
<script src="https://leejay.top/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
