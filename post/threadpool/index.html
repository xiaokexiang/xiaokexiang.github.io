<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>ThreadPool线程池源码解析 :: Keep Improving</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="ThreadPool 为什么使用线程池 我们知道频繁的单独创建线程是很消耗系统资源的，而线程池中线程是可以线程复用的，不需要每次执行都重新创建，并且线程池可以提供控制线程个数等资源限制和管理的手段。
实现原理 所谓线程池实现原理：调用方不断向线程池中添加任务，线程池中有一组线程，不断的从队列中取任务。典型的生产者和消费者模型。基于这样的原理，我们实现线程池需要使用到阻塞队列，避免无任务时轮询带来的资源消耗。
线程池类继承体系  ThreadPoolExecutor和ScheduledExecutorService是需要关注的两个核心类，前者是线程池的具体实现，后者除了能实现线程池的基本功能，还可以提供周期性执行任务功能。
任何需要线程池执行的任务，都必须直接或间接的实现Runnable接口。
  ThreadPoolExecutor 构造 // 阻塞队列，具体实现由构造函数决定 private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue; private volatile int corePoolSize; private volatile int maximumPoolSize; private volatile long keepAliveTime; // 线程工厂，用于定义创建线程的方式，主要是定义线程name等相关参数 private volatile ThreadFactory threadFactory; // 拒绝策略有4种内置的策略 private volatile RejectedExecutionHandler handler; // 参数最多的构造函数 public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,  ThreadFactory threadFactory,  RejectedExecutionHandler handler) {  if (corePoolSize &amp;lt; 0 ||  maximumPoolSize &amp;lt;= 0 ||  maximumPoolSize &amp;lt; corePoolSize ||  keepAliveTime &amp;lt; 0)  throw new IllegalArgumentException();  if (workQueue == null || threadFactory == null || handler == null)  throw new NullPointerException();  this." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://leejay.top/post/threadpool/" />




<link rel="stylesheet" href="https://leejay.top/assets/style.css">






<link rel="apple-touch-icon" href="https://leejay.top/img/favicon.png">

  <link rel="shortcut icon" href="https://leejay.top/img/favicon.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="ThreadPool线程池源码解析">
<meta property="og:description" content="`ThreadPool`可以避免单个线程创建带来的系统资源的消耗，并且能够实现线程的复用，有效节省系统资源。" />
<meta property="og:url" content="https://leejay.top/post/threadpool/" />
<meta property="og:site_name" content="Keep Improving" />

  
    <meta property="og:image" content="https://leejay.top/img/favicon.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

  <meta property="article:section" content="Concurrent" />

  <meta property="article:section" content="ThreadPool" />


  <meta property="article:published_time" content="2020-07-17 17:01:26 &#43;0800 &#43;0800" />










<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code">

</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://leejay.top">
  <div class="logo">
    HelloWorld
  </div>
</a>

    </div>
    
  </div>
  
</header>


  <div class="content">
    
<div class="post">
  
  
    









<div class="toc" id="toc_id">

    <div class="page-header"><strong>- CATALOG -</strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#threadpool">
                    ThreadPool
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0">
                    为什么使用线程池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
                    实现原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%b1%bb%e7%bb%a7%e6%89%bf%e4%bd%93%e7%b3%bb">
                    线程池类继承体系
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#threadpoolexecutor">
                    ThreadPoolExecutor
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e6%9e%84%e9%80%a0">
                    构造
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#worker">
                    Worker
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#ctl%e5%8f%98%e9%87%8f">
                    ctl变量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%85%b3%e9%97%ad">
                    线程池的关闭
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#shutdown">
                    shutDown
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#tryterminate">
                    tryTerminate
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#await">
                    await
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#shutdownnow">
                    shutDownNow
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e6%ad%a3%e7%a1%ae%e7%9a%84%e5%85%b3%e9%97%ad%e7%ba%bf%e7%a8%8b%e6%b1%a0">
                    正确的关闭线程池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e6%80%bb%e7%bb%93">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%b7%bb%e5%8a%a0%e4%bb%bb%e5%8a%a1">
                    线程池添加任务
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#execute">
                    execute
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#addworker">
                    addWorker
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1">
                    线程池执行任务
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#runworker">
                    runWorker
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#gettask">
                    getTask
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#processworkerexit">
                    processWorkerExit
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5">
                    线程池拒绝策略
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%89%a7%e8%a1%8c%e7%a4%ba%e6%84%8f%e5%9b%be">
                    线程池执行示意图
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e9%97%ae%e9%a2%98%e6%b1%87%e6%80%bb">
                    线程池问题汇总
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



  
  <h1 class="post-title">
    <a href="https://leejay.top/post/threadpool/">ThreadPool线程池源码解析</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2020-07-17 
      </span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://leejay.top/tags/threadpool-/">ThreadPool </a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <h3 id="threadpool">ThreadPool<a href="#threadpool" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="为什么使用线程池">为什么使用线程池<a href="#为什么使用线程池" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>我们知道频繁的<code>单独创建线程</code>是很消耗系统资源的，而线程池中线程是可以<code>线程复用</code>的，不需要每次执行都重新创建，并且线程池可以提供<code>控制线程个数</code>等资源限制和管理的手段。</p>
<h4 id="实现原理">实现原理<a href="#实现原理" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>所谓线程池实现原理：<code>调用方不断向线程池中添加任务，线程池中有一组线程，不断的从队列中取任务</code>。典型的<code>生产者和消费者模型</code>。基于这样的原理，我们实现线程池需要使用到<code>阻塞队列</code>，避免无任务时轮询带来的资源消耗。</p>
<h4 id="线程池类继承体系">线程池类继承体系<a href="#线程池类继承体系" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p><img src="https://image.leejay.top/image/20200714/4QO7osHQeOu6.png?imageslim" alt=""></p>
<blockquote>
<p><code>ThreadPoolExecutor</code>和<code>ScheduledExecutorService</code>是需要关注的两个核心类，前者是<code>线程池的具体实现</code>，后者除了能实现线程池的基本功能，还可以提供<code>周期性执行任务</code>功能。</p>
<p>任何需要线程池执行的任务，都必须<code>直接或间接的实现Runnable接口</code>。</p>
</blockquote>
<hr>
<h3 id="threadpoolexecutor">ThreadPoolExecutor<a href="#threadpoolexecutor" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="构造">构造<a href="#构造" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 阻塞队列，具体实现由构造函数决定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 线程工厂，用于定义创建线程的方式，主要是定义线程name等相关参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> ThreadFactory threadFactory<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 拒绝策略有4种内置的策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> RejectedExecutionHandler handler<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数最多的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                          TimeUnit unit<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                          BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                          ThreadFactory threadFactory<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                          RejectedExecutionHandler handler<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>corePoolSize <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        maximumPoolSize <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        maximumPoolSize <span style="color:#f92672">&lt;</span> corePoolSize <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        keepAliveTime <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workQueue <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> threadFactory <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> handler <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">acc</span> <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">getSecurityManager</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    AccessController<span style="color:#f92672">.</span><span style="color:#a6e22e">getContext</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">corePoolSize</span> <span style="color:#f92672">=</span> corePoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maximumPoolSize</span> <span style="color:#f92672">=</span> maximumPoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">workQueue</span> <span style="color:#f92672">=</span> workQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">keepAliveTime</span> <span style="color:#f92672">=</span> unit<span style="color:#f92672">.</span><span style="color:#a6e22e">toNanos</span><span style="color:#f92672">(</span>keepAliveTime<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">threadFactory</span> <span style="color:#f92672">=</span> threadFactory<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> handler<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p><code>corePoolSize</code>：线程池中始终维护的线程个数，不受超时影响的核心线程。</p>
<p><code>maxPoolSize</code>：<code>在corePoolSize已满，且队列已满会扩充线程至此值</code>，在此之前只有核心线程执行任务。</p>
<p><code>workQueue</code>：阻塞队列，任务会被添加到队列中，具体实现由使用者决定。</p>
<p><code>keepAliveTime</code>：<code>maxPoolSize</code>中的空闲线程销毁需要的时间，销毁后线程数降至<code>corePoolSize</code>。</p>
<p><code>threadFactory</code>：线程工厂，用于生产线程，主要用来定义线程名字等相关参数。</p>
<p><code>handler</code>：当<code>corePoolSize</code>、<code>maxPoolSize</code>和<code>workQueue</code>都满时的执行的拒绝策略。</p>
</blockquote>
<h4 id="worker">Worker<a href="#worker" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//Worker组成的HashSet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> HashSet<span style="color:#f92672">&lt;</span>Worker<span style="color:#f92672">&gt;</span> workers <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;</span>Worker<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Worker</span> <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer 
</span></span><span style="display:flex;"><span>    						<span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Worker维护的线程就是用来执行任务的线程，每个Worker对应一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> Thread thread<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Worker对象的初始任务，因为线程复用就会存在一个woker执行多个任务的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Runnable firstTask<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 记录当前worker完成的任务次数，volatile修饰
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> completedTasks<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 构造函数，需要传入初始任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Worker<span style="color:#f92672">(</span>Runnable firstTask<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 初始状态设为-1，启动时会被清除，这里很重要！目的是防止被中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        setState<span style="color:#f92672">(-</span>1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> firstTask<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 调用工厂类创建线程，任务是当前的woker对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> getThreadFactory<span style="color:#f92672">().</span><span style="color:#a6e22e">newThread</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// worker被调用时会执行run方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 运行当前worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        runWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>Worker类主要用于维护<code>执行任务线程的中断控制状态</code>。</p>
<ol>
<li>Worker<code>实现了Runnable接口中的run方法</code>，初始化时将<code>worker作为Runnable任务</code>传入创建了线程。</li>
<li>Worker继承<code>AbstractQueueSynchronizer</code>抽象类，用于<code>简化获取和释放围绕每个Worker执行的锁</code>，为了通过中断唤醒<code>空闲中的线程</code>而<code>非正在运行中的任务</code>(后面的代码会解释)，同时实现了自己的获取锁和释放锁的逻辑，是为了<code>避免锁的重入</code>。</li>
<li>Worker初始化<code>设置state为-1</code>，直到真正启动时才会清除，是为了<code>防止该worker还没执行就被打断</code>。</li>
</ol>
</blockquote>
<h4 id="ctl变量">ctl变量<a href="#ctl变量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 状态变量由 线程池运行状态(高3位)和线程池内有效线程数量(低29位)组成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始值：1110 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> AtomicInteger ctl <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>ctlOf<span style="color:#f92672">(</span>RUNNING<span style="color:#f92672">,</span> 0<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// COUNT_BITS = 29 用于移位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> COUNT_BITS <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">SIZE</span> <span style="color:#f92672">-</span> 3<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 线程数量最多 CAPACITY = 2^29-1 (0001 1111 1111 1111 1111 1111 1111 1111 )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CAPACITY   <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1111 1111 1111 1111 1111 1111 1111 1111 -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 1110 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> RUNNING    <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0000 0000 0000 0000 0000 0000 0000 0000 -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 0000 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SHUTDOWN   <span style="color:#f92672">=</span>  0 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0000 0000 0000 0000 0000 0000 0000 0001 -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 0010 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> STOP       <span style="color:#f92672">=</span>  1 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0000 0000 0000 0000 0000 0000 0000 0010 -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 0100 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TIDYING    <span style="color:#f92672">=</span>  2 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0000 0000 0000 0000 0000 0000 0000 0011 -&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 0110 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TERMINATED <span style="color:#f92672">=</span>  3 <span style="color:#f92672">&lt;&lt;</span> COUNT_BITS<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ~CAPACITY = 1110 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// c &amp; !CAPACITY 只会得到高3位的bit值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">runStateOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span>     <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>CAPACITY<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取低29位的bit值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">workerCountOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span>  <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&amp;</span> CAPACITY<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将高3位和低29位组装成ctl值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ctlOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> rs<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> wc<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> rs <span style="color:#f92672">|</span> wc<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">runStateLessThan</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&lt;</span> s<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">runStateAtLeast</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&gt;=</span> s<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isRunning</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c <span style="color:#f92672">&lt;</span> SHUTDOWN<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CAS减ctl值加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndIncrementWorkerCount</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> expect<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>expect<span style="color:#f92672">,</span> expect <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CAS将ctl的值减1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndDecrementWorkerCount</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> expect<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>expect<span style="color:#f92672">,</span> expect <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环执行CAS直到减ctl减1成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">decrementWorkerCount</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> <span style="color:#f92672">{}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span> compareAndDecrementWorkerCount<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">()));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>ctl状态变量由<code>线程池运行状态(高3位)</code>和<code>线程池内有效线程数量(低29位)</code>构成。</p>
<p>线程池的状态只会<code>从小到大迁移(-1-&gt;0-&gt;1-&gt;2-&gt;3)</code>，不会逆向迁移。</p>
<p><code>RUNNING</code>：<code>能够接收新的任务</code>，及<code>执行在队列中的任务</code>。</p>
<p><code>SHUTDOWN</code>：不能接收新任务，但还是会<code>执行在队列中的任务</code>。</p>
<p><code>STOP</code>：不能接收新任务，也不会执行在队列中的任务，最后中断正在执行的任务。</p>
<p><code>TIDYING</code>：所有任务都终止，worker数量变为0，转换为此状态会执行<code>terminated()</code>钩子函数。</p>
<p><code>TERMINATED</code>：<code>terminated()</code>执行完毕，至此线程池才真正关闭。</p>
<p><img src="https://image.leejay.top/image/20200714/C5qLgqKHxr5W.png?imageslim" alt="线程迁移状态"></p>
</blockquote>
<hr>
<h3 id="线程池的关闭">线程池的关闭<a href="#线程池的关闭" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>我们先从<code>shutDown</code>和<code>shutDownNow</code>两个方法入手，先了解线程池如何关闭的。</p>
<h4 id="shutdown">shutDown<a href="#shutdown" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shutdown</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 校验是否由关闭线程池的权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        checkShutdownAccess<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将ctl修改为SHUTDOWN态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        advanceRunState<span style="color:#f92672">(</span>SHUTDOWN<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        interruptIdleWorkers<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 钩子函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// ScheduledThreadPoolExecutor用于清除delay任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        onShutdown<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改线程池状态(TIDYING TERMINATED状态的处理)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tryTerminate<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将ctl状态转换为目标状态或已经变成目标状态时保持不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// targetState 可以是 SHUTDOWN或STOP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">advanceRunState</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> targetState<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取ctl状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 如果runStateAtLeast成立，说明 c &gt;= targetState
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 说明状态已经比target还大，那么不需要再修改了，保持不变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 2. step1不成立则CAS修改ctl状态直到将状态修改为targetState
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runStateAtLeast<span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> targetState<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> ctlOf<span style="color:#f92672">(</span>targetState<span style="color:#f92672">,</span> workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">))))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interruptIdleWorkers</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    interruptIdleWorkers<span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 中断可能正在等待任务的线程(某些线程可能不会被中断)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// onlyOne = true 至少中断一个worker线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interruptIdleWorkers</span><span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> onlyOne<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取独占锁(独占锁重入了)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历每个worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Worker w <span style="color:#f92672">:</span> workers<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取worker的属性thread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Thread t <span style="color:#f92672">=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 1. 如果当前线程没有被中断，那么执行step2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 2. 尝试获取当前worker线程的独占锁(worker本身就是锁，且只会有一个线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 竞争该锁) 如果获取失败说明当前线程正在执行任务，它不是空闲的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 只有1和2都成立才会中断当前线程。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">isInterrupted</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">tryLock</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 中断当前线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    t<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupt</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>SecurityException ignore<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 释放worker锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    w<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果为true说明只需要中断一个，break
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>onlyOne<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p><code>shutDown</code>不会接受新的任务，但会执行先前提交的任务。如果已shutDown，再次执行不会有影响。</p>
<p>执行流程：</p>
<ol>
<li>获取独占锁，保证关闭操作和其他操作互斥。</li>
<li>校验是否有关闭线程池权限。</li>
<li>自旋修改ctl为<code>SHUTDOWN</code>态，如果此时<code>ctl &gt; SHUTDOWN</code>，则不做修改。</li>
<li>中断<code>所有未被中断且空闲的worker</code>线程。</li>
<li>释放独占锁，并执行<code>tryTerminate</code>方法，处理线程池状态转换、执行<code>terminate</code>和唤醒等操作。</li>
</ol>
</blockquote>
<h4 id="tryterminate">tryTerminate<a href="#tryterminate" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tryTerminate</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 自旋执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取ctl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ①正在RUNNING ② 线程池状态大于等于TIDYING 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// ③ 当前状态为shutDown且队列不为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 三者一个成立就返回，不继续执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isRunning<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            runStateAtLeast<span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> TIDYING<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">(</span>runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果当前worker线程数量不为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 中断一个空闲worker线程并返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            interruptIdleWorkers<span style="color:#f92672">(</span>ONLY_ONE<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 只有此处才会修改状态为TIDYING!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// CAS将ctl修改为TIDYING|0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> ctlOf<span style="color:#f92672">(</span>TIDYING<span style="color:#f92672">,</span> 0<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 至此说明状态为TIDYING,workerCount = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 调用terminated钩子函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    terminated<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 只有此处才会修改状态为TERMINATED!!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 将状态设为TERMINATED|0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>ctlOf<span style="color:#f92672">(</span>TERMINATED<span style="color:#f92672">,</span> 0<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 唤醒awaitTermination方法中等待的线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    termination<span style="color:#f92672">.</span><span style="color:#a6e22e">signalAll</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<ol>
<li>如果<code>为SHUTDOWN态、线程池和队列为空</code>或<code>为STOP态且线程池为空</code>则转换为<code>TIDYING、TERMINATED</code>。</li>
<li>如果是<code>SHUTDOWN或STOP态</code>但<code>workCount!=0</code>，那么会中断空闲的线程，保证关机的信号传播。</li>
<li><code>tryTerminate</code>方法并不会强制关机，它只是在正确的时间将线程池状态改为<code>TIDYING</code>后执行<code>terminated</code>钩子函数，最后再唤醒执行了<code>awaitTermination</code>的线程。</li>
<li>只有<code>tryTerminate</code>方法才会将<code>ctl</code>修改为<code>TIDYING</code>或<code>TERMINATED</code>，且<code>自旋+CAS</code>直到成功。</li>
<li>我们需在<code>任何可能终止的操作之后</code>，调用<code>tryTerminate</code>方法。比如<code>减少worker线程数量</code>或<code>在shutdown期间从队列中删除任务</code>。</li>
</ol>
</blockquote>
<h4 id="await">await<a href="#await" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 阻塞直到三个条件满足其一：1. 所有任务在shutdown后完成 2. 超时 3.当前线程被中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">awaitTermination</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">,</span> TimeUnit unit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    								<span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> nanos <span style="color:#f92672">=</span> unit<span style="color:#f92672">.</span><span style="color:#a6e22e">toNanos</span><span style="color:#f92672">(</span>timeout<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 循环执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果成立说明线程池状态时TERMINATED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runStateAtLeast<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(),</span> TERMINATED<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 超时了那么退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nanos <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 否则调用condition.awaitNanos等待指定时长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            nanos <span style="color:#f92672">=</span> termination<span style="color:#f92672">.</span><span style="color:#a6e22e">awaitNanos</span><span style="color:#f92672">(</span>nanos<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p><code>awaitTermination</code>会阻塞直到以下三个条件满足其一：</p>
<ol>
<li>在调用<code>shutDown或shutDownNow</code>后，所有任务都已完成。</li>
<li>指定时间超时了。</li>
<li>当前线程被中断了。</li>
</ol>
<p>在<code>tryTerminate</code>方法中确实存在<code>唤醒因执行awaitTermination方法等待的线程</code>的代码。</p>
</blockquote>
<h4 id="shutdownnow">shutDownNow<a href="#shutdownnow" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 该方法会尝试中断所有正在执行的任务，返回正在等待执行的任务列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">shutdownNow</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> tasks<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 校验是否有关闭线程池的权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        checkShutdownAccess<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 自旋执行CAS修改ctl为STOP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果shutDown方法释放锁后，执行tryTerminate前，线程执行了shutDownNow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 那么会发生SHUTDOWN -&gt; STOP状态的转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        advanceRunState<span style="color:#f92672">(</span>STOP<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 中断正在执行的线程和正在等待的线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        interruptWorkers<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 返回正在等待的worker线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        tasks <span style="color:#f92672">=</span> drainQueue<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    tryTerminate<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tasks<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 中断全部worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interruptWorkers</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这里并没有使用tryLock进行线程空闲判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Worker w <span style="color:#f92672">:</span> workers<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            w<span style="color:#f92672">.</span><span style="color:#a6e22e">interruptIfStarted</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 注意方法名，已经开始的才能中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interruptIfStarted</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Thread t<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 我们初始化worker对象的时候把state设为了-1，这里的getState&gt;=0是保证刚创建的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// worker对象不能被打断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// thread != null只是正常的判空校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果线程没被中断那么中断当前线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>getState<span style="color:#f92672">()</span> <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">=</span> thread<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">isInterrupted</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            t<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupt</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>SecurityException ignore<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将阻塞队列中的任务转成list返回，如果是延时队列或其他导致不能通过drainTo转移的任务，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环删除并添加到list中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> List<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">drainQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取构造函数指定的阻塞队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> q <span style="color:#f92672">=</span> workQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建用于返回的list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ArrayList<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> taskList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将阻塞队列中的Runnable转移到list，并删除旧的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    q<span style="color:#f92672">.</span><span style="color:#a6e22e">drainTo</span><span style="color:#f92672">(</span>taskList<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>q<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这里设置了数组大小为1(数组大小确定不会变化)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 通过循环每次都获取q中的一个任务，直到成功移除它，添加到队list，再执行下一任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Runnable r <span style="color:#f92672">:</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">[</span>0<span style="color:#f92672">]))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>q<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>r<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                taskList<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>r<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> taskList<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p><code>shutDownNow</code>会<code>中断正在执行及正在等待的worker线程</code>。并会<code>返回阻塞队列中的全部任务并删除</code>。</p>
<p><code>shutDownNow</code>执行流程：</p>
<ol>
<li>获取独占锁，保证关闭操作和其他操作互斥。</li>
<li>校验是否有关闭线程池权限。</li>
<li>自旋修改ctl为<code>STOP</code>态，如果此时<code>ctl &gt; STOP</code>，则不做修改。如果此时<code>ctl = SHUTDOWN</code>，那么会将<code>SHUTDOWN</code>改为<code>STOP</code>，也就是10-12行代码注释所释。</li>
<li>中断<code>所有正在执行的线程及正在等待的线程(刚创建的state=-1worker线程不会被中断)</code>，并<code>在返回阻塞队列中的全部任务并清空队列</code>。</li>
<li>释放独占锁，并执行<code>tryTerminate</code>方法，处理线程池状态转换、执行<code>terminate</code>和唤醒等操作。</li>
</ol>
</blockquote>
<h4 id="正确的关闭线程池">正确的关闭线程池<a href="#正确的关闭线程池" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Slf4j</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutorTest</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ExecutorService POOL <span style="color:#f92672">=</span> ThreadPoolSingleton<span style="color:#f92672">.</span><span style="color:#a6e22e">getInstance</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        POOL<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;prepare to sleep ...&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>5000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>        POOL<span style="color:#f92672">.</span><span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span><span style="color:#75715e">// 也可以使用shutDownNow()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;调用shutDown方法 ... &#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> loop<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                loop <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>POOL<span style="color:#f92672">.</span><span style="color:#a6e22e">awaitTermination</span><span style="color:#f92672">(</span>3<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>loop<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Thread Pool 真正关闭拉 ...&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            log<span style="color:#f92672">.</span><span style="color:#a6e22e">error</span><span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">getMessage</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 线程池的单例类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolSingleton</span> <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">ThreadPoolSingleton</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Can not exec constructor&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ThreadPoolExecutor <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Holder<span style="color:#f92672">.</span><span style="color:#a6e22e">THREAD_POOL_EXECUTOR</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Holder</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ThreadPoolExecutor THREAD_POOL_EXECUTOR <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>                2<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                32<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                60<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>10<span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> CustomizableThreadFactory<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Thread-Pool-&#34;</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">CallerRunsPolicy</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">readResolve</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getInstance<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="总结">总结<a href="#总结" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ul>
<li>
<p><code>shutDown</code>和<code>shutDownNow</code>都会去<code>修改ctl状态</code>，并<code>中断线程</code>，最后调用<code>tryTerminate</code>方法。</p>
</li>
<li>
<p>shutDown和shutDownNow区别</p>
<table>
<thead>
<tr>
<th></th>
<th>中断线程类型</th>
<th>阻塞队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>shutDown</td>
<td>中断空闲线程</td>
<td>不清空阻塞队列，等待任务全部执行完成</td>
</tr>
<tr>
<td>shutDownNow</td>
<td>中断空闲线程和正在执行线程</td>
<td>清空阻塞队列，并返回阻塞队列中的任务</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>tryTerminate</code>只是处理<code>TIDYING</code>和<code>TERMINATED</code>状态、执行钩子函数及唤醒等待线程，<code>不会强制关机</code>。</p>
</li>
<li>
<p>线程池关闭的流程状态图</p>
<p><img src="https://image.leejay.top/image/20200714/C5qLgqKHxr5W.png?imageslim" alt=""></p>
</li>
</ul>
<hr>
<h3 id="线程池添加任务">线程池添加任务<a href="#线程池添加任务" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="execute">execute<a href="#execute" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 提交任务给线程池，没有获取独占锁的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// command不能为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>command <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取ctl变量，默认是 RUNNING|0 即 1110 0000 0000 0000 0000 0000 0000 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断worker数量是否小于corePoolSize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 添加worker线程并把任务交给worker，true表示往核心池中添加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 添加成功返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 添加失败获取ctl变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 此处失败原因：corePoolSize已经满了或线程池终止了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 所以判断是否还在RUNNING状态，如果是就往阻塞队列添加任务，如果队列满会返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isRunning<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">offer</span><span style="color:#f92672">(</span>command<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 任务添加到队列成功，继续判断状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> recheck <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 因为execute不是获取锁执行，所以如果刚添加完线程成功，另一个线程调用shutDown
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 方法修改为SHUTDOWN态， 所以需要继续判断，如果此时不是RUNNING，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 那么调用remove移除当前任务，如果移除成功，那么调用拒绝策略。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果调用失败，有可能这个任务刚被执行了，就会删除失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> isRunning<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> remove<span style="color:#f92672">(</span>command<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>            reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 执行到此存在两种情况: 1. 此时还是RUNNING态 2. 不是RUNNING态，移除任务失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 针对1此时存在任务，但workercount = 0，所以需要创建线程来执行这个任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 针对2，如果任务刚被拿走，那么worker线程数不会为0。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            addWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 至此说明corePoolSize满了，队列也满了，那么添加线程直到maxPoolSize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果还添加失败，说明已经达到maxPoolSize了。调用拒绝策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 移除任务，如果任务已被执行那么就返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>Runnable task<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从队列中移除任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> removed <span style="color:#f92672">=</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>task<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 之前分析tryTerminate时说过：任何可能终止操作后调用tryTerminate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tryTerminate<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> removed<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 调用拒绝策略具体的实现类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reject</span><span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    handler<span style="color:#f92672">.</span><span style="color:#a6e22e">rejectedExecution</span><span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>执行流程：</p>
<ol>
<li>判断<code>workerCount &lt; corePoolSize</code>是否成立，成立调用<code>addWorker</code>并返回，不成立执行step2。</li>
<li>如果处于<code>RUNNING态 &amp;&amp; 任务加入阻塞队列</code>，不成功调用step3。若成功，因为execute方法没有加锁执行，所以需要<code>double-check</code>状态，如果<code>不处于RUNNING态则尝试移除刚添加的任务</code>，若<code>处于RUNNING态或移除失败</code>，判断当前<code>workerCount == 0</code>，成立则调用<code>addWorker</code>添加线程执行刚加入的任务。</li>
<li>执行至此，说明：要么<code>线程池不处于RUNNING态</code>，调用<code>addWorker</code>添加线程也会返回false，执行<code>reject</code>拒绝策略。要么<code>corePoolSize和阻塞队列已满</code>，那么调用<code>addWorker</code>当线程数达到<code>maxPoolSize</code>时也会返回false，执行<code>reject</code>拒绝策略。</li>
</ol>
</blockquote>
<h4 id="addworker">addWorker<a href="#addworker" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 核心方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">addWorker</span><span style="color:#f92672">(</span>Runnable firstTask<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> core<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    retry<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ① 第一个自旋: 根据状态的不同，判断是否需要增加workerCount
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取ctl变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取运行状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果 rs != SHUTDOWN 就不需要再处理了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// rs = SHUTDOWN时，不接受新的任务(task != null)，处理队列中的任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// rs = SHUTDOWN时，无任务时，队列不为空就帮助执行队列中任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">!</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">!</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// ② 第二个自旋：主要处理workerCount是否超过阈值及自增
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取worker线程数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果wc超过阈值，直接返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// core: true就和corePoolSzie比，false就和maxPoolSize比
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>wc <span style="color:#f92672">&gt;=</span> CAPACITY <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                wc <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span>core <span style="color:#f92672">?</span> corePoolSize <span style="color:#f92672">:</span> maximumPoolSize<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 尝试CAS将ctl + 1	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndIncrementWorkerCount<span style="color:#f92672">(</span>c<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 成功才能跳出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span> retry<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 再次获取ctl判断rs状态是否被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 在执行addWorker的期间，另一个线程尝试修改了运行状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 被修改就继续外层循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span> retry<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 第三部分 ③
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 表示任务是否开启
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表示任务是否添加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Worker w <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建worker对象，赋予任务，并通过线程工厂创建处理该任务的线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 注意此处的task 可能等于 null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Worker<span style="color:#f92672">(</span>firstTask<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取执行任务的线程，如果因为线程工厂创建线程返回null或线程启动导致的OOM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 都会导致此处的t=null，那么在finally中会回滚
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">final</span> Thread t <span style="color:#f92672">=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 获取锁后还要判断状态，因为可能在获取锁等待的时候状态被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// rs = RUNNING 或 （rs = SHUTDOWN 且 task = null）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 状态为SHUTDOWN，但任务为null也添加到池中，因为此时的阻塞队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 肯定不为空，用于协助处理任务，让线程池早点关机
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&lt;</span> SHUTDOWN <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">(</span>rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 判断线程是否start或还没有dead
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">isAlive</span><span style="color:#f92672">())</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalThreadStateException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 添加到HashSet&lt;Worker&gt;中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    workers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 获取队列大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> workers<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 只有这个地方会修改largePoolSize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 这里的判断说明存在另一处会移除worker，所以要保证
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 只有队列大小大于当前largePoolSize再更新该成员变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">&gt;</span> largestPoolSize<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                        largestPoolSize <span style="color:#f92672">=</span> s<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 修改变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 释放独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 只有添加到worker队列中才会启动任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerAdded<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 执行Worker类中的run方法，下一章分析
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                t<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 修改变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 第四部分④
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// workerStarted = false，那么workerAdded肯定是false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 说明 t=null | t!=null但(rs &gt; shutdown or(rs=shutdown但task!=null)）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> workerStarted<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 任务回滚
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            addWorkerFailed<span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> workerStarted<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 没有成功添加任务，那么需要回滚
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addWorkerFailed</span><span style="color:#f92672">(</span>Worker w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 移除worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>w <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            workers<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将workerCount-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        decrementWorkerCount<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 调用tryTerminate，因为可能线程池被shutdown了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        tryTerminate<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>执行流程分为四个部分进行分析：</p>
<ol>
<li>
<p>第一部分对线程池的状态进行判断，<code>继续执行第二部分</code>需要符合以下两个条件中一个即可：</p>
<p>① 线程池状态为<code>RUNNING</code>。</p>
<p>② 线程池状态为<code>SHUTDOWN</code>时，<code>firstTask == null</code>且<code>阻塞队列不为空</code>。(辅助理解：当线程池状态为<code>SHUTDOWN</code>时<code>不接受新的任务</code>，但是<code>已存在阻塞队列中的任务当前线程可以协助执行</code>。)</p>
</li>
<li>
<p>第二部分判断<code>workerCount是否超过阈值</code>，如果没有则<code>CAS修改workerCount</code>，如果<code>workerCount CAS</code>修改期间状态变化，则回到第一部分继续执行。</p>
</li>
<li>
<p>第三部分创建<code>worker对象</code>，并<code>加入线程池中</code>，之后<code>开启线程执行任务</code>。如下情况执行第四部分：</p>
<p>① 当前worker对象<code>通过线程工厂创建的线程返回null</code>。</p>
<p>② 获取独占锁过程中状态变化了：<code>rs != RUNNING</code> 且 <code>rs = SHUTDOWN 时 firstTask != null</code>。</p>
</li>
<li>
<p>第四部分执行回滚操作：<code>移除worker</code>、<code>CAS将workerCount减1</code>和<code>调用tryTerminate</code>。</p>
</li>
</ol>
<p>addWorker方法主要是<code>添加worker线程到线程池中，并启动线程执行任务</code>，worker线程分为两类：</p>
<ol>
<li>
<p><code>有firstTask任务</code>的线程。</p>
</li>
<li>
<p><code>没有firstTask任务</code>的协助线程：</p>
<p>① 线程池<code>处于SHUTDOWN期间，协助快速处理阻塞队列任务</code>的线程。</p>
<p>② 线程池中<code>没有固定线程(即corePoolSize=0)</code>，但此时有任务需要执行的情况。</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="线程池执行任务">线程池执行任务<a href="#线程池执行任务" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="runworker">runWorker<a href="#runworker" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 因为worker对象本身就是实现了Runnable接口，所以线程启动时调用run方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    runWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Worker unlock的核心方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> unused<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不会判断是你是否是持有独占锁的线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    setExclusiveOwnerThread<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    setState<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runWorker</span><span style="color:#f92672">(</span>Worker w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取当前线程，即执行该任务的线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Thread wt <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Runnable task <span style="color:#f92672">=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">firstTask</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将firstTask属性设为null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    w<span style="color:#f92672">.</span><span style="color:#a6e22e">firstTask</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// unlock会将state设为0，为什么这里这样？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因为初始化worker对象的时候会将state设为-1，防止线程池的中断方法中断刚创建的worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 除此之外还为了下面的w.lock，能够正常的获取独占锁，也方便了shutDown方法中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 判断线程是否空闲的tryLock的正确执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    w<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> completedAbruptly <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果task != null说明当前线程有任务的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果task = null说明是协助线程，需要去阻塞队列拿任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>task <span style="color:#f92672">=</span> getTask<span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 至此肯定拿到了任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 为什么此处要获取锁，worker独占锁只会被当前一个线程持有啊？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 1. shutDown方法中调用的中断方法会通过tryLock判断线程是否空闲
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 2. 避免worker线程被中断，worker实现了独占锁大部分功能，不及时响应中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            w<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果线程池正在终止，那么中断当前线程，如果不是，那么不让线程被中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>runStateAtLeast<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(),</span> STOP<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupted</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                  runStateAtLeast<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(),</span> STOP<span style="color:#f92672">)))</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">!</span>wt<span style="color:#f92672">.</span><span style="color:#a6e22e">isInterrupted</span><span style="color:#f92672">())</span>
</span></span><span style="display:flex;"><span>                wt<span style="color:#f92672">.</span><span style="color:#a6e22e">interrupt</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 钩子函数，用于自定义任务执行前调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                beforeExecute<span style="color:#f92672">(</span>wt<span style="color:#f92672">,</span> task<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                Throwable thrown <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 这里用户传入的任务才真正被执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    task<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>RuntimeException x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    thrown <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#66d9ef">throw</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Error x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    thrown <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#66d9ef">throw</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    thrown <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error<span style="color:#f92672">(</span>x<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 钩子函数，任务执行后调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    afterExecute<span style="color:#f92672">(</span>task<span style="color:#f92672">,</span> thrown<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 清空task
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                task <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将completeTask + 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                w<span style="color:#f92672">.</span><span style="color:#a6e22e">completedTasks</span><span style="color:#f92672">++;</span>
</span></span><span style="display:flex;"><span>                w<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 修改completedAbruptly参数。如果为true说明是异常结束的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        completedAbruptly <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 处理worker的退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        processWorkerExit<span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> completedAbruptly<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<ol>
<li><code>runWorker</code>方法会判断<code>firstTask != null</code>是否成立，如果不成立再去<code>阻塞队列中获取任务</code>。</li>
<li><code>w.lock()</code>后的第一处判断，主要目的：<code>如果线程池正在中断，那么中断当前线程。如果不是，那么不让当前线程被中断</code>（<code>w.lock</code>后<code>state=1</code>，所以是能被<code>shutDownNow</code>中的中断方法中断的）。</li>
<li>调用<code>beforeExecute</code>钩子函数，此时才真正的执行用户传入的任务。</li>
<li>执行<code>afterExecute</code>钩子函数，清空task，将<code>workrer.completedTasks+1</code></li>
<li>如果<code>getTask返回null</code>或<code>执行任务发生异常</code>，最终调用<code>processWorkerExit</code>方法。</li>
</ol>
</blockquote>
<h4 id="gettask">getTask<a href="#gettask" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 从阻塞队列中获取任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Runnable <span style="color:#a6e22e">getTask</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用于判断上次poll是否超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">boolean</span> timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 自旋执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取ctl状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取运行状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果线程池正在shutdown 或 队列已空，那么将workerCount-1并返回null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> STOP <span style="color:#f92672">||</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            decrementWorkerCount<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获取workerCount
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// allowCoreThreadTimeOut表示核心数量的线程不允许超时，默认false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// wc &gt; corePoolSize时返回true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> timed <span style="color:#f92672">=</span> allowCoreThreadTimeOut <span style="color:#f92672">||</span> wc <span style="color:#f92672">&gt;</span> corePoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 因为setMaximumPoolSize，所以wc &gt; max会出现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 1. 如果wc超过max 或 (wc大于corePoolSize且上次poll超时了)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>wc <span style="color:#f92672">&gt;</span> maximumPoolSize <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>timed <span style="color:#f92672">&amp;&amp;</span> timedOut<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果wc&gt;1或队列为空，一直减少wc直到1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>wc <span style="color:#f92672">&gt;</span> 1 <span style="color:#f92672">||</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndDecrementWorkerCount<span style="color:#f92672">(</span>c<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果是true调用poll阻塞，否则调用take阻塞获取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Runnable r <span style="color:#f92672">=</span> timed <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">(</span>keepAliveTime<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">NANOSECONDS</span><span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">take</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 不为null返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 为null设置timeOut继续循环，也就是worker一直在获取任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException retry<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果getTask过程中被中断了，继续循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            timedOut <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<ol>
<li>第一个判断：如果线程池状态变成<code>SHUTDOWN或队列已空</code>，那么将<code>workerCount减1并返回null</code>。</li>
<li><code>allowCoreThreadTimeOut</code>参数表明<code>corePoolSize指定数量的核心线程能否超时，默认为false</code>。</li>
<li>第二个判断：如果 ①<code>wc超过maxPoolSize</code>或<code>(wc &gt; corePoolSize 且 上次poll超时)</code>，那么继续判断。 ②<code>wc &gt; 1或 阻塞队列为空</code>，若两者都成立，那么会将wc减1，多次循环后可能<code>wc=1</code>。</li>
<li>根据<code>wc &gt; corePoolSize</code>返回<code>true/false</code>来决定调用的是<code>poll(time)/take()</code>，前者阻塞<code>keepAliveTime</code>，后者<code>一直阻塞直到获取了任务</code>。最终一定会有<code>小于等于corePoolSize数量的线程</code>一直在take处阻塞等待任务。</li>
<li>如果<code>获取的任务!=null</code>则返回，否则设置<code>timeOut=true</code>。发生异常则设置<code>timeOut=false</code>。</li>
</ol>
</blockquote>
<h4 id="processworkerexit">processWorkerExit<a href="#processworkerexit" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// completedAbruptly =true表明runWorker是异常退出的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processWorkerExit</span><span style="color:#f92672">(</span>Worker w<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> completedAbruptly<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果异常退出，那么将workerCount减1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>completedAbruptly<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        decrementWorkerCount<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将成员变量completedTaskCount加上worker处理的线程数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        completedTaskCount <span style="color:#f92672">+=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">completedTasks</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从线程池中移除该worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        workers<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 移除worker后必须调用的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tryTerminate<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取ctl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断状态是否小于STOP，即使是SHUTDOWN状态，也需要将队列中任务全部执行完成才行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 所以需要保持&gt;=corePoolSize数量的worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runStateLessThan<span style="color:#f92672">(</span>c<span style="color:#f92672">,</span> STOP<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// worker非异常退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>completedAbruptly<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断保留corePoolSize数量的线程是否超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> allowCoreThreadTimeOut <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> corePoolSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果min=0,但阻塞队列不为空，至少保留一个worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>min <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>
</span></span><span style="display:flex;"><span>                min <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果min!=0,且workerCount &gt;= min直接退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;=</span> min<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span> <span style="color:#75715e">// replacement not needed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果是异常退出，直接addWorker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果workerCount&lt; min，增加一个null task的worker
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        addWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>何时调用此方法处理worker的退出？</p>
<p>① 执行<code>runWorker</code>方法时发生了异常。</p>
<p>② <code>getTask方法返回null</code>时会调用。</p>
<ol>
<li>
<p>如果<code>completedAbruptly=true</code>说明<code>runWorker</code>异常退出，将<code>workerCount-1</code>.</p>
</li>
<li>
<p>获取独占锁，将worker执行的任务数传递给线程池<code>completedTaskCount</code>并移除该worker。</p>
</li>
<li>
<p>如果<code>rs &lt; STOP</code>时：</p>
<p>① 当前worker正常退出的，如果<code>allowCoreThreadTimeOut=true</code>且<code>队列不为空</code>，那么至少保留一个worker。如果<code>allowCoreThreadTimeOut=false</code>，那么仅在<code>workerCount &lt; corePoolSize</code>时增加一个worker。</p>
<p>② 如果当前worker非正常退出的，直接添加一个worker。</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="线程池拒绝策略">线程池拒绝策略<a href="#线程池拒绝策略" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>直接抛出一个RejectedExecutionException异常</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接由调用者执行该任务，如果线程池关闭，该任务会被丢弃</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>不做处理，将该任务直接丢弃</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列中最老的任务并重试该任务，如果线程池关闭，该任务会被丢弃</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="线程池执行示意图">线程池执行示意图<a href="#线程池执行示意图" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p><img src="https://image.leejay.top/image/20200716/sMWBHgaW5lsx.png?imageslim" alt=""></p>
<hr>
<h3 id="线程池问题汇总">线程池问题汇总<a href="#线程池问题汇总" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>为什么Worker类选择继承了AQS而不是直接使用ThreadPoolExecutor的ReentrentLock？</li>
</ul>
<blockquote>
<p>源码注释：Doug lea希望实现的是<code>非可重入的互斥锁</code>，不希望worker在调用类似<code>setCorePoolSize</code>之类的线程池控制方法时能够重新获取该锁。</p>
<p>因为<code>需要符合一定的条件才能中断worker线程</code>，这个条件是通过设置<code>state=-1</code>来实现。而ThreadPoolExecutor中的<code>ReentrantLock</code>不能实现这个需求，所以需要额外继承AQS。</p>
<p><code>setCorePoolSize-&gt; interruptIdleWorkers()-&gt; interruptIdleWorkers(false)-&gt; tryLock()</code></p>
</blockquote>
<ul>
<li>为什么初始化Worker对象时会将state设为-1？</li>
</ul>
<blockquote>
<p>Worker对象在初始化的时候会将<code>state = -1</code>，<code>防止worker在刚初始化后还没有执行任务就被中断</code>。因为<code>shutDown和shutDownNow</code>方法中都有中断线程的方法，只是逻辑不同而已，前者是通过<code>tryLock</code>来中断空闲线程(<code>只有state=0时才会成功</code>)，后者是通过<code>state &gt;= 0将已初始化还未执行</code>的worker排除在外。</p>
</blockquote>
<ul>
<li>为什么runWorker方法中会先调用unlock再调用lock方法？</li>
</ul>
<blockquote>
<p><code>worker.unlock</code>方法的核心在于<code>tryRelease</code>方法，该方法设置<code>state = 0</code>后，lock方法才有可能执行成功，<code>否则永远无法获取锁</code>。除此之外还有控制中断的作用：</p>
<ol>
<li><code>当前worker可以被后续shutDownNow中断操作所中断</code>。</li>
<li><code>让后续调用shutDown操作的线程通过tryLock判断worker是否空闲</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> unused<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果是state=-1，CAS永远不会成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        setExclusiveOwnerThread<span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></blockquote>
<ul>
<li>线程池为何能够持有线程不释放，在有任务的时候立即执行？</li>
</ul>
<blockquote>
<p>核心在于<code>getTask</code>方法中，<code>核心线程</code>会执行<code>take()</code>方法阻塞直到任务到来，<code>非核心线程</code>会执行<code>poll()阻塞keepAliveTime后超时</code>，<code>getTask</code>返回null，最终调用<code>processWorkerExit</code>让当前worker推出。</p>
</blockquote>
<ul>
<li>线程池corePoolSize该如何设置？</li>
</ul>
<blockquote>
<p>corePoolSize用于设置<code>指定数量的核心线程</code>，这些线程是即使<code>闲置和超时也不会被回收的</code>。</p>
<p>corePoolSize的设置基于以下公式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>NThreads <span style="color:#f92672">=</span> NCPUS <span style="color:#f92672">*</span> UCPU <span style="color:#f92672">*</span> <span style="color:#f92672">(</span>1 <span style="color:#f92672">+</span> W<span style="color:#f92672">/</span>C<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>NThreads<span style="color:#960050;background-color:#1e0010">：</span>线程数量
</span></span><span style="display:flex;"><span>NCpus<span style="color:#960050;background-color:#1e0010">：</span>cpu核数<span style="color:#f92672">(</span>Runtime<span style="color:#f92672">.</span><span style="color:#a6e22e">getRuntime</span><span style="color:#f92672">().</span><span style="color:#a6e22e">availableProcessors</span><span style="color:#f92672">()</span>可计算<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>UCpus: cpu使用率<span style="color:#f92672">(</span>0<span style="color:#f92672">~</span>1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>W<span style="color:#f92672">/</span>C<span style="color:#960050;background-color:#1e0010">：</span> wait time<span style="color:#f92672">/</span>compute time  Cpu运行类型分为I<span style="color:#f92672">/</span>O密集型<span style="color:#f92672">(</span>W<span style="color:#f92672">)</span>和计算密集型<span style="color:#f92672">(</span>C<span style="color:#f92672">)</span>    
</span></span></code></pre></div><p>假设：CPU使用率是100%，那么公式可以变成：<code>NThreads = NCpus * (1 + W/C)</code></p>
<ol>
<li>如果是<code>I/O密集型(数据库交互、文件上传下载、网络数据传输等)</code>，W越大，那么 W/C &gt; 1， NThreads &gt;= 2 * NCpus。</li>
<li>如果是<code>计算密集型(复杂算法之类的)</code>，W 接近于0，NThreads &gt;= NCpus，推荐NCpus+1，这样即使<code>当计算密集型线程偶尔由于缺失故障或者其他原因线程暂停，这个额外的线程也能确保CPU时钟周期不被浪费</code>， 至于多一个cpu上下文切换是否值得，具体项目具体测试。</li>
</ol>
<p>推荐：<code> I/O密集型： NThread = 2NCpu。 计算密集型 NThread = NCpus + 1</code>。</p>
</blockquote>
<ul>
<li>Scheduled线程池中<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>的区别</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execRate</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    ScheduledExecutorService executorService <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">scheduleAtFixedRate</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; Start: scheduleAtFixedRate:  &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1_000<span style="color:#f92672">);</span> <span style="color:#75715e">// 任务执行需要1s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; End  : scheduleAtFixedRate:    &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">},</span> 2L<span style="color:#f92672">,</span> 3L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">);</span> <span style="color:#75715e">// 间隔3s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 Start: scheduleAtFixedRate:    Thu Apr 08 14:06:32 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 End  : scheduleAtFixedRate:    Thu Apr 08 14:06:33 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 Start: scheduleAtFixedRate:    Thu Apr 08 14:06:35 CST 2021 35-32=3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 End  : scheduleAtFixedRate:    Thu Apr 08 14:06:36 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 Start: scheduleAtFixedRate:    Thu Apr 08 14:06:38 CST 2021 38-35=3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 End  : scheduleAtFixedRate:    Thu Apr 08 14:06:39 CST 2021
</span></span></span></code></pre></div><blockquote>
<ol>
<li>如果线程执行任务的时间小于period设置的时间，那么即使上个线程任务执行完毕，下个线程也会等到<code>与上个线程相差period时间</code>后才会执行下个任务。</li>
<li>如果线程执行任务的时间大于period设置的时间，那么线程任务执行完毕就会立即开始执行下个任务，因为时差已经达到了period。</li>
</ol>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execDelay</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    ScheduledExecutorService executorService <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">scheduleWithFixedDelay</span><span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Start: scheduleWithFixedDelay: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1_000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;End  : scheduleWithFixedDelay: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Date<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">},</span> 2L<span style="color:#f92672">,</span> 2L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 Start: scheduleWithFixedDelay: Thu Apr 08 14:12:29 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 End  : scheduleWithFixedDelay: Thu Apr 08 14:12:30 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 Start: scheduleWithFixedDelay: Thu Apr 08 14:12:32 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 End  : scheduleWithFixedDelay: Thu Apr 08 14:12:33 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 Start: scheduleWithFixedDelay: Thu Apr 08 14:12:35 CST 2021
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pool-1-thread-1 End  : scheduleWithFixedDelay: Thu Apr 08 14:12:36 CST 2021
</span></span></span></code></pre></div><blockquote>
<p>下个线程必须与上个线程相差<code>线程执行时长 + Delay时长</code>，才会开始执行下个任务。</p>
</blockquote>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">其他文章</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://leejay.top/post/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">
                <span class="button__icon">←</span>
                <span class="button__text">Jvm类加载机制</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="https://leejay.top/post/hotspot%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">
                <span class="button__text">HotSpot垃圾回收算法</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>苏ICP备18050258号</span>
    
        
      </div>
  </div>
</footer>

<script src="https://leejay.top/assets/main.js"></script>
<script src="https://leejay.top/assets/prism.js"></script>







  
</div>

</body>
</html>
