<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>ReentrantLock源码解析 :: Keep Improving</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Lock与Synchronized都是可重入锁，否则会发生死锁。Lock锁核心在于AbstractQueueSynchronizer，又名队列同步器(简称AQS)。如果需要实现自定义锁，除了需要实现Lock接口外，还需要内部类继承Sync类。
AbstractQueueSynchronizer 记录当前锁的持有线程 由AQS的父类AbstractOwnableSynchronizer实现记录当前锁的持有线程功能（独占锁）。
state变量 内部维护了volatile修饰的state变量，state = 0时表明没有线程获取锁，state = 1时表明有一个线程获取锁，当state &amp;gt; 1时，说明该线程重入了该锁。
线程的中断 interrupt 将线程的中断标识设置为true，并不是让线程立马停止执行。 isInterrupted 判断线程的中断状态，不会对当前线程中断状态产生任何影响。 interrupted 判断当前线程的中断状态，但是会清楚当前线程的中断标识（即为false）。 线程阻塞和唤醒 由LockSupport类实现，其底层是调用了Unsafe的park 和 unpark。
如果当前线程是非中断状态，调用park则线程阻塞，如果当前线程是中断状态，调用park()会立即返回也是为什么AQS要清空中断状态的原因。 park方法不会抛出中断异常（也不会清除中断状态），如果先调用unpark再调用park，那么park也会立马返回。 连续调用多次unpark方法，效果等同于调用一次unpark方法。 park方法和sleep方法相同，不会释放资源，而wait方法会释放资源。 park方法将Runnable -&amp;gt; WAITING/TIME_WAITING，unpark方法将WAITING/TIME_WAITING -&amp;gt; Runnable。 FIFO队列 AQS内部维护了一个基于CLH(Craig, Landin, and Hagersten(CLH)locks。基于链表的公平的自旋锁)变种的FIFO双向链表阻塞队列，在等待机制上由自旋改成阻塞唤醒(park/unpark)。
还未初始化的时候，head = tail = null，之后初始化队列，往其中假如阻塞的线程时，会新建一个空的node，让head和tail都指向这个空node。之后加入被阻塞的线程对象。当head=tai时候说明队列为空。
Node的waitStatus Node状态 描述 INIT=0 Node初始创建时默认为0 CANCELLED=1 由于超时或者中断，线程获取锁的请求取消了，节点一旦变成此状态就不会再变化。 SIGNAL=-1 表示线程已经准备好了，等待资源释放去获取锁。 CONDITION=-2 表示节点处于等待队列中，等待被唤醒。 PROPAGATE=-3 只有当前线程处于SHARED情况下，该字段才会使用，用于共享锁的获取。 ReentrentLock 我们选择ReentrentLock作为入口进行源码解读，自定义的获取释放锁的方法，由其内部抽象类Sync的子类FairSync和NonfairSync中的tryAcquire、tryRelease实现。
class Test { private static final ReentrantLock LOCK = new ReentrantLock(); public void run() { LOCK." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://blog.leejay.top/post/concurrent_reentrant_lock/" />




<link rel="stylesheet" href="https://blog.leejay.top/assets/style.css">






<link rel="apple-touch-icon" href="https://blog.leejay.top/img/favicon.png">

  <link rel="shortcut icon" href="https://blog.leejay.top/img/favicon.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="ReentrantLock源码解析">
<meta property="og:description" content="AbstractQueueSynchronizer是一种同步框架，而ReentrantLock是基于它实现的`可重入独占锁`，具有公平/非公平两种实现。" />
<meta property="og:url" content="https://blog.leejay.top/post/concurrent_reentrant_lock/" />
<meta property="og:site_name" content="Keep Improving" />

  
    <meta property="og:image" content="https://blog.leejay.top/img/favicon.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

  <meta property="article:section" content="Concurrent" />


  <meta property="article:published_time" content="2020-06-15 15:53:46 &#43;0800 &#43;0800" />










<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code">

</head>
<body class="orange">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://blog.leejay.top/">
  <div class="logo">
    HelloWorld
  </div>
</a>

    </div>
    
  </div>
  
  
  <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

</header>


  <div class="content">
    
<div class="post">
  
  
    









<div class="toc" id="toc_id">

    <div class="page-header"><strong> ↓ 目录 ↓ </strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#abstractqueuesynchronizer">
                    AbstractQueueSynchronizer
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e8%ae%b0%e5%bd%95%e5%bd%93%e5%89%8d%e9%94%81%e7%9a%84%e6%8c%81%e6%9c%89%e7%ba%bf%e7%a8%8b">
                    记录当前锁的持有线程
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#state%e5%8f%98%e9%87%8f">
                    state变量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%b8%ad%e6%96%ad">
                    线程的中断
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%ba%bf%e7%a8%8b%e9%98%bb%e5%a1%9e%e5%92%8c%e5%94%a4%e9%86%92">
                    线程阻塞和唤醒
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#fifo%e9%98%9f%e5%88%97">
                    FIFO队列
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#node%e7%9a%84waitstatus">
                    Node的waitStatus
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#reentrentlock">
                    ReentrentLock
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e5%85%ac%e5%b9%b3%e9%94%81%e5%92%8c%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81">
                    公平锁和非公平锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#acquire">
                    acquire
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#tryacquire">
                    tryAcquire
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#hasqueuedpredecessors">
                    hasQueuedPredecessors
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#addwaiter">
                    addWaiter
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#acquirequeued">
                    acquireQueued
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#cancelacquire">
                    cancelAcquire
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#selfinterrupt">
                    selfInterrupt
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#%e7%8b%ac%e5%8d%a0%e9%94%81%e8%8e%b7%e5%8f%96%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b">
                    独占锁获取执行流程
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#unlock">
                    unlock
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#lockinterruptibly">
                    lockInterruptibly
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link" href="#trylocktime">
                    tryLock(time)
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



  
  <h1 class="post-title">
    <a href="https://blog.leejay.top/post/concurrent_reentrant_lock/">ReentrantLock源码解析</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2020-06-15 
      </span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://blog.leejay.top/tags/reentrantlock-/">ReentrantLock </a>&nbsp;
    
    #<a href="https://blog.leejay.top/tags/aqs/">AQS</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <p>Lock与Synchronized都是<code>可重入锁</code>，否则会发生死锁。Lock锁核心在于<code>AbstractQueueSynchronizer</code>，又名<code>队列同步器(简称AQS)</code>。如果需要实现自定义锁，除了需要实现Lock接口外，还需要内部类继承Sync类。</p>
<h3 id="abstractqueuesynchronizer">AbstractQueueSynchronizer<a href="#abstractqueuesynchronizer" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p><img src="https://image.leejay.top/image/20200608/GVtL7ztzwtCl.png?imageslim" alt=""></p>
<h4 id="记录当前锁的持有线程">记录当前锁的持有线程<a href="#记录当前锁的持有线程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>由AQS的父类<code>AbstractOwnableSynchronizer</code>实现记录当前锁的持有线程功能（独占锁）。</p>
<h4 id="state变量">state变量<a href="#state变量" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>内部维护了volatile修饰的state变量，state = 0时表明没有线程获取锁，state = 1时表明有一个线程获取锁，当state &gt; 1时，说明该线程重入了该锁。</p>
<h4 id="线程的中断">线程的中断<a href="#线程的中断" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ul>
<li>interrupt
将线程的中断标识设置为true，并不是让线程立马停止执行。</li>
<li>isInterrupted
判断线程的中断状态，不会对当前线程中断状态产生任何影响。</li>
<li>interrupted
判断当前线程的中断状态，但是会清楚当前线程的中断标识（即为false）。</li>
</ul>
<h4 id="线程阻塞和唤醒">线程阻塞和唤醒<a href="#线程阻塞和唤醒" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>由<code>LockSupport</code>类实现，其底层是调用了Unsafe的park 和 unpark。</p>
<ol>
<li>如果当前线程是非中断状态，调用park则线程阻塞，如果当前线程是中断状态，调用park()会立即返回<code>也是为什么AQS要清空中断状态的原因</code>。</li>
<li>park方法不会抛出中断异常（也不会清除中断状态），如果先调用unpark再调用park，那么park也会立马返回。</li>
<li>连续调用多次unpark方法，效果等同于调用一次unpark方法。</li>
<li>park方法和sleep方法相同，不会释放资源，而wait方法会释放资源。</li>
<li>park方法将Runnable -&gt; WAITING/TIME_WAITING，unpark方法将WAITING/TIME_WAITING -&gt; Runnable。</li>
</ol>
<h4 id="fifo队列">FIFO队列<a href="#fifo队列" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>AQS内部维护了一个基于<code>CLH(Craig, Landin, and Hagersten(CLH)locks。基于链表的公平的自旋锁)</code>变种的FIFO双向链表阻塞队列，在等待机制上由自旋改成阻塞唤醒(park/unpark)。</p>
<p><img src="https://image.leejay.top/image/20200609/CHJldTlsLVp2.png?imageslim" alt=""></p>
<blockquote>
<p>还未初始化的时候，head = tail = null，之后初始化队列，往其中假如阻塞的线程时，会新建一个空的node，让head和tail都指向这个空node。之后加入被阻塞的线程对象。当head=tai时候说明队列为空。</p>
</blockquote>
<h4 id="node的waitstatus">Node的waitStatus<a href="#node的waitstatus" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<table>
<thead>
<tr>
<th style="text-align:left">Node状态</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">INIT=0</td>
<td style="text-align:left">Node初始创建时默认为0</td>
</tr>
<tr>
<td style="text-align:left">CANCELLED=1</td>
<td style="text-align:left">由于超时或者中断，线程获取锁的请求取消了，节点一旦变成此状态就不会再变化。</td>
</tr>
<tr>
<td style="text-align:left">SIGNAL=-1</td>
<td style="text-align:left">表示线程已经准备好了，等待资源释放去获取锁。</td>
</tr>
<tr>
<td style="text-align:left">CONDITION=-2</td>
<td style="text-align:left">表示节点处于等待队列中，等待被唤醒。</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATE=-3</td>
<td style="text-align:left">只有当前线程处于SHARED情况下，该字段才会使用，用于共享锁的获取。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="reentrentlock">ReentrentLock<a href="#reentrentlock" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>我们选择<code>ReentrentLock</code>作为入口进行源码解读，自定义的获取释放锁的方法，由其内部抽象类Sync的子类FairSync和NonfairSync中的tryAcquire、tryRelease实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ReentrantLock LOCK <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        LOCK.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//dosomething</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            LOCK.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>判断是否成功获取锁的标志，就是CAS修改volatile修饰的state变量是否成功。</p>
</blockquote>
<h3 id="公平锁和非公平锁">公平锁和非公平锁<a href="#公平锁和非公平锁" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 非公平锁实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NonfairSync</span> <span style="color:#66d9ef">extends</span> Sync {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 先尝试CAS获取锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (compareAndSetState(0, 1))
</span></span><span style="display:flex;"><span>            setExclusiveOwnerThread(Thread.<span style="color:#a6e22e">currentThread</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 再排队</span>
</span></span><span style="display:flex;"><span>            acquire(1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 公平锁实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FairSync</span> <span style="color:#66d9ef">extends</span> Sync {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> serialVersionUID <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>3000897897090466540L;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 去排队</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() {
</span></span><span style="display:flex;"><span>        acquire(1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>公平锁和非公平锁如何选择？</p>
<p>非公平锁一进来就尝试去获取锁，有效的减少了线程的上下文切换，所以为了追求<code>高吞吐量</code>建议选择非公平锁，但是会导致某些线程长时间在排队，没有机会获取锁。否则建议选择公平锁。</p>
</blockquote>
<h3 id="acquire">acquire<a href="#acquire" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 如果第一次获取锁失败，说明此时有其他线程持有锁，所以执行acquire</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquire</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tryAcquire(arg) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        acquireQueued(addWaiter(Node.<span style="color:#a6e22e">EXCLUSIVE</span>), arg))
</span></span><span style="display:flex;"><span>        selfInterrupt();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="tryacquire">tryAcquire<a href="#tryacquire" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 调用非公平锁的tryAcquire，再一次尝试去获取锁</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> nonfairTryAcquire(acquires);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回false表明没有获取到锁，true表明成功获取锁/重入锁</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">nonfairTryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取当前线程</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread current <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取state状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果state是0，表明当前没有线程获取锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 尝试去获取锁，获取成功就设置独占线程为当前线程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (compareAndSetState(0, acquires)) {
</span></span><span style="display:flex;"><span>            setExclusiveOwnerThread(current);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果当前线程已经是独占线程，此时说明锁重入了</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (current <span style="color:#f92672">==</span> getExclusiveOwnerThread()) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 修改state的值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c <span style="color:#f92672">+</span> acquires;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nextc <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 设置state值，因为此时的获取锁的线程就是当前线程</span>
</span></span><span style="display:flex;"><span>        setState(nextc);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 公平锁的tryAcquire实现</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// hasQueuedPredecessors是公平锁的主要体现</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>hasQueuedPredecessors() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                compareAndSetState(0, acquires)) {
</span></span><span style="display:flex;"><span>                setExclusiveOwnerThread(current);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Q:  为什么有的地方使用setState()，有的地方使用CAS？</p>
<p>A:  因为使用setState()方法的前提是已经获取了锁，使用了CAS的是因为此时还没有获取锁。</p>
</blockquote>
<h4 id="hasqueuedpredecessors">hasQueuedPredecessors<a href="#hasqueuedpredecessors" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// true/false 有节点在等待/无节点等待</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasQueuedPredecessors</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里为什么tail获取在head之前？</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 假设第一个节点入队，根据enq()设置head和tail可知</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果此处tail = null，head = null | head != null都有可能</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果此处tail != null ，那么(head = tail) != null</span>
</span></span><span style="display:flex;"><span>    Node t <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>    Node h <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    Node s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">!=</span> t <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// (s = h.next) == null 成立说明有其他线程正在初始化队列</span>
</span></span><span style="display:flex;"><span>        ((s <span style="color:#f92672">=</span> h.<span style="color:#a6e22e">next</span>) <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">!=</span> Thread.<span style="color:#a6e22e">currentThread</span>());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>返回情况分析：</p>
<ol>
<li>
<p>若<code>h == t</code>说明此时队列还没有初始化或只有哨兵节点，返回false表明无等待节点。</p>
</li>
<li>
<p>若<code>h != t</code>成立，说明此时队列有节点啊，那<code>((s = h.next) == null)</code>应该也成立啊？
其实不然，我们假设线程A获取锁失败，尝试加入队列，此时队列还未初始化，A执行到enq方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enq</span>(<span style="color:#66d9ef">final</span> Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>        Node t <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 线程A准备初始化队列，它setHead(new Node())成功了</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 此时线程切换，线程B执行了hasQueuedPredecessors()</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 此时 head != null; tail = null; head.next = null</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 此时h != t 且 (s = h.next) = null</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndSetHead(<span style="color:#66d9ef">new</span> Node()))
</span></span><span style="display:flex;"><span>                tail <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndSetTail(t, node)) {
</span></span><span style="display:flex;"><span>                t.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> t;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>若<code>((s = h.next) == null)</code>成立，说明此时存在另一个线程执行到<code>compareAndSetHead(new Node())</code>和<code>tail = head</code>的中间状态。所以也需要返回true，表明有节点在等待。</p>
</li>
<li>
<p>若<code>((s = h.next) == null)</code>不成立，我们继续判断队列中第一个等待线程（<code>s.thread != Thread.currentThread()</code>）是否是当前线程，是就返回true，否则返回false。</p>
</li>
<li>
<p>方法中为什么<code>Node t = tail</code>获取在<code>Node h = head</code>之前？
根据上面的分析，我们知道第一个节点入队的时候会出现<code>head != null 但 tail = null</code>的情况，因为是<code>先设置head再设置tail</code>，操作非原子性。
我们假设<code>队列未初始化</code>，hasQueuedPredecessors方法中<code>tail和head代码位置互换</code>，线程A先执行<code>Node h = head;</code>此时<code>head = null</code>，线程切换，线程B执行enq方法初始化队列导致<code>（head = tail）!= null</code>，又切回线程A，执行<code>Node t = tail</code>，<code>tail != null</code>，判断代码<code>h != t</code>成立，继续判断<code>(s = h.next) == null</code>出问题了，<code>h =null,h.next会抛空指针!!!</code>，这就是问题所在。(再次膜拜Doug lea！！！)</p>
</li>
</ol>
</blockquote>
<h4 id="addwaiter">addWaiter<a href="#addwaiter" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 获取不到锁，将当前线程构建成node对象加入队列</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">addWaiter</span>(Node mode) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建node对象(currentThread, Node.EXCLUSIVE)</span>
</span></span><span style="display:flex;"><span>    Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(Thread.<span style="color:#a6e22e">currentThread</span>(), mode);
</span></span><span style="display:flex;"><span>    Node pred <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果尾节点不等于null，说明队列不为空</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pred <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 设置node的prev为尾节点</span>
</span></span><span style="display:flex;"><span>        node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果此时有两个线程尝试用将node设置为tail尾节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 所以需要CAS保证只有一个设置成功，另一个执行下面的enq()加入队列</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (compareAndSetTail(pred, node)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 设置成功后，添加next指针指向node</span>
</span></span><span style="display:flex;"><span>            pred.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尾节点为null 或 插入尾节点失败</span>
</span></span><span style="display:flex;"><span>    enq(node);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环执行插入操作，直到插入队尾成功</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enq</span>(<span style="color:#66d9ef">final</span> Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>        Node t <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果尾节点是null，说明队列还没有初始化</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将head设置成空node，并且tail=head(说明此时队列初始化了但还没有节点)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndSetHead(<span style="color:#66d9ef">new</span> Node()))
</span></span><span style="display:flex;"><span>                tail <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// t!=null，设置node.prev=t</span>
</span></span><span style="display:flex;"><span>            node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// CAS设置node到队尾，如果不成功继续循环获取tail直到设置成功</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndSetTail(t, node)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// CAS成功，设置t的next属性</span>
</span></span><span style="display:flex;"><span>                t.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 跳出循环返回node的前驱节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> t;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="acquirequeued">acquireQueued<a href="#acquirequeued" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 至此node已经插入队列成功，并返回</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">acquireQueued</span>(<span style="color:#66d9ef">final</span> Node node, <span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取node的前继节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">predecessor</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果node的前继节点是头节点，则node尝试去获取锁</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// tryAcquire(arg)会抛出异常</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire(arg)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 获取锁成功，设置头节点为node，并清空thread和prev属性</span>
</span></span><span style="display:flex;"><span>                setHead(node);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 方便回收前继节点p</span>
</span></span><span style="display:flex;"><span>                p.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 修改failed参数</span>
</span></span><span style="display:flex;"><span>                failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 跳出循环并返回</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> interrupted;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果前继节点不是head节点 或 前继节点是head节点但获取不到锁</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断是否需要挂起,如果阻塞节点被唤醒，还会继续循环获取，直到获取锁才return</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                parkAndCheckInterrupt())
</span></span><span style="display:flex;"><span>                interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果跳出循环，failed=false，不跳出循环也不会执行到这里</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 也就是只有tryAcquire(arg)发生异常了才会执行cancelAcquire()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (failed)
</span></span><span style="display:flex;"><span>            cancelAcquire();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> Node <span style="color:#a6e22e">predecessor</span>() <span style="color:#66d9ef">throws</span> NullPointerException {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取node的prev节点p</span>
</span></span><span style="display:flex;"><span>    Node p <span style="color:#f92672">=</span> prev;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果p为null则抛出异常，这里的空指针一般不会生效，只是为了帮助虚拟机</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 否则返回前继节点p</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将node节点设置为head头节点，获取锁之后都会将头节点相关信息清除</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHead</span>(Node node) {
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    node.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断获取锁失败之后是否需要park</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">shouldParkAfterFailedAcquire</span>(Node pred, Node node) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取node前继节点的waitStatus，默认情况下值为0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">waitStatus</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果是signal，说明前继节点已经准备就绪，等待被占用的资源释放</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">==</span> Node.<span style="color:#a6e22e">SIGNAL</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果前继节点waitStatus&gt;0，说明是Cancel</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取前继节点的前继节点，直到它的状态&gt;0(直到前继节点不是cancel节点)</span>
</span></span><span style="display:flex;"><span>            node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">prev</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将不是cancel的节点与node相连</span>
</span></span><span style="display:flex;"><span>        pred.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 尝试将前继节点pred设置成signal状态，设置signal的作用是什么？</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在解锁的时候只有head!=null且为signal状态才会唤醒head的下个节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果pred状态设置成功，第二次就会进入ws == Node.SIGNAL，返回true</span>
</span></span><span style="display:flex;"><span>        compareAndSetWaitStatus(pred, ws, Node.<span style="color:#a6e22e">SIGNAL</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将线程挂起并检查是否被中断</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parkAndCheckInterrupt</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 挂机当前线程，不会往下执行了</span>
</span></span><span style="display:flex;"><span>    LockSupport.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 往下执行的条件: unpark(t)或被中断</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回中断状态(并清空中断状态)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Thread.<span style="color:#a6e22e">interrupted</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>LockSupport.park()除了<code>能够被unpark()唤醒，还会响应interrupt()打断</code>，但是Lock锁不能响应中断，如果是unpark，会返回false，如果是interrupt则返回true。</p>
</blockquote>
<h4 id="cancelacquire">cancelAcquire<a href="#cancelacquire" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 节点取消获取锁</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cancelAcquire</span>(Node node) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 忽略不存在的node</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 清空node的thread属性</span>
</span></span><span style="display:flex;"><span>      node.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 获取node的不是cancel的前继节点</span>
</span></span><span style="display:flex;"><span>      Node pred <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">prev</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>          node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">prev</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 获取有效前继节点的后继节点</span>
</span></span><span style="display:flex;"><span>      Node predNext <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 设置node节点为cancel状态</span>
</span></span><span style="display:flex;"><span>      node.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">=</span> Node.<span style="color:#a6e22e">CANCELLED</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果node是tail尾节点，将pred(非cancel节点)设置为尾节点</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> tail <span style="color:#f92672">&amp;&amp;</span> compareAndSetTail(node, pred)) {
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 设置尾节点pred的next指针为null</span>
</span></span><span style="display:flex;"><span>          compareAndSetNext(pred, predNext, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">int</span> ws;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 如果node不是tail尾节点</span>
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 1.pred不是头节点</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (pred <span style="color:#f92672">!=</span> head <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 2.如果不是则判断前继节点状态是否是signal</span>
</span></span><span style="display:flex;"><span>              ((ws <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">waitStatus</span>) <span style="color:#f92672">==</span> Node.<span style="color:#a6e22e">SIGNAL</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>               <span style="color:#75715e">// 3.如果不是signal则尝试将pred前继节点设置为signal</span>
</span></span><span style="display:flex;"><span>               (ws <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> compareAndSetWaitStatus(pred, ws, Node.<span style="color:#a6e22e">SIGNAL</span>))) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 4.判断前继节点线程信息是否为null</span>
</span></span><span style="display:flex;"><span>              pred.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 1，2/3，4条件满足，获取node的后继节点</span>
</span></span><span style="display:flex;"><span>              Node next <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 如果后继节点不为null且waitStatus&lt;=0</span>
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> next.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0)
</span></span><span style="display:flex;"><span>                  <span style="color:#75715e">// 将node的前继节点的后继节点改成node的后继节点</span>
</span></span><span style="display:flex;"><span>                  compareAndSetNext(pred, predNext, next);
</span></span><span style="display:flex;"><span>          } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">// 如果node前继不是head &amp; 也不是tail</span>
</span></span><span style="display:flex;"><span>              unparkSuccessor(node);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>  		<span style="color:#75715e">// 将node的后继节点设置为自身，方便回收</span>
</span></span><span style="display:flex;"><span>          node.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 唤醒head节点后不为cancel的非null节点</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unparkSuccessor</span>(Node node) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">waitStatus</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果node.waitStatus &lt; 0 ，将其设置为0(初始状态)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>          compareAndSetWaitStatus(node, ws, 0);
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 获取node的后继节点</span>
</span></span><span style="display:flex;"><span>      Node s <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果后继节点为null或是cancel，循环查找直到不符合该条件的node</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>          s <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 重点：从队尾往前找！！！！</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">for</span> (Node t <span style="color:#f92672">=</span> tail; t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> t <span style="color:#f92672">!=</span> node; t <span style="color:#f92672">=</span> t.<span style="color:#a6e22e">prev</span>)
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> (t.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0)
</span></span><span style="display:flex;"><span>                  s <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 找到不为cancel的非null节点</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 唤醒对应的线程</span>
</span></span><span style="display:flex;"><span>          LockSupport.<span style="color:#a6e22e">unpark</span>(s.<span style="color:#a6e22e">thread</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Q：为什么AQS的队列查找中，是从队列尾从后向前查找的？</p>
<p>A：节点入队时，都是遵循如下范式设置tail节点：</p>
<p><code>① node.prev = tail; </code></p>
<p><code>② if(compareAndSetTail(tail, node)) { </code></p>
<p><code>			③ tail.next = node; }</code></p>
<p>②和③两行代码不是原子性的，所以就存在：线程A将nodeA成功设置为tail尾节点，如果此时线程切换，线程B执行unparkSuccessor方法唤醒尾节点，如果从前往后查询，会发现<code>tail.next = null</code>，会认为tail是尾节点，其实此时的尾节点已经被线程A改成了nodeA，doug lea在AQS的文档中也说明了<code>prev是务必要保证的可靠引用，而next只是一种优化。</code></p>
<p>又比如cancelAcquire方法中，都是断开了next指针，prev指针没有断开，也是上诉理论的一种体现。</p>
</blockquote>
<h4 id="selfinterrupt">selfInterrupt<a href="#selfinterrupt" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 当获取锁或插入node到队列的过程中发生了interrupt，那么这里需要补上打断</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selfInterrupt</span>() {
</span></span><span style="display:flex;"><span>    Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">interrupt</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="独占锁获取执行流程">独占锁获取执行流程<a href="#独占锁获取执行流程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p><img src="https://image.leejay.top/image/20200628/9RLQ683DruWq.png?imageslim" alt=""></p>
<h3 id="unlock">unlock<a href="#unlock" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试释放锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (tryRelease(arg)) {
</span></span><span style="display:flex;"><span>        Node h <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果头节点不为null且不是初始状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">!=</span> 0)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 唤醒头节点的后继节点</span>
</span></span><span style="display:flex;"><span>            unparkSuccessor(h);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 唤醒的线程会重新从parkAndCheckInterrupt()方法中被unpark</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 然后继续新一轮的获取锁或者获取不到锁park的流程</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span>(<span style="color:#66d9ef">int</span> releases) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 此时处于已获取锁状态，所以不需要cas获取state，这里也会处理多次重入的情况</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState() <span style="color:#f92672">-</span> releases;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果当前线程不是独占线程抛异常</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Thread.<span style="color:#a6e22e">currentThread</span>() <span style="color:#f92672">!=</span> getExclusiveOwnerThread())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalMonitorStateException();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> free <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果state=0说明独占锁或锁重入释放准备完毕</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>        free <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        setExclusiveOwnerThread(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置状态为0</span>
</span></span><span style="display:flex;"><span>    setState(c);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 释放锁成功</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> free;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="lockinterruptibly">lockInterruptibly<a href="#lockinterruptibly" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>可及时响应线程中断的获取锁的API</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 方法入口</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lockInterruptibly</span>() <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>  sync.<span style="color:#a6e22e">acquireInterruptibly</span>(1);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 可响应中断</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquireInterruptibly</span>(<span style="color:#66d9ef">int</span> arg)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果线程被打断直接抛出异常</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Thread.<span style="color:#a6e22e">interrupted</span>())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试去获取锁，获取失败将node加入队列，被中断抛出异常</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tryAcquire(arg))
</span></span><span style="display:flex;"><span>        doAcquireInterruptibly(arg);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 与acquireQueue几乎相同</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doAcquireInterruptibly</span>(<span style="color:#66d9ef">int</span> arg)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        	parkAndCheckInterrupt())
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 与acquireQueue唯一的区别</span>
</span></span><span style="display:flex;"><span>        	<span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException();
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="trylocktime">tryLock(time)<a href="#trylocktime" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>响应中断且非阻塞，指定时间内获取不到锁就返回。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span>(<span style="color:#66d9ef">long</span> timeout, TimeUnit unit)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sync.<span style="color:#a6e22e">tryAcquireNanos</span>(1, unit.<span style="color:#a6e22e">toNanos</span>(timeout));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 与lockInterruptibly相同抛出中断异常切换尝试获取锁，获取锁过程中响应中断</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquireNanos</span>(<span style="color:#66d9ef">int</span> arg, <span style="color:#66d9ef">long</span> nanosTimeout)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Thread.<span style="color:#a6e22e">interrupted</span>())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果获取锁失败就去执行doAcquireNanos，直到超时返回false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tryAcquire(arg) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        doAcquireNanos(arg, nanosTimeout);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 获取锁的超时方法</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">doAcquireNanos</span>(<span style="color:#66d9ef">int</span> arg, <span style="color:#66d9ef">long</span> nanosTimeout)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throws</span> InterruptedException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nanosTimeout <span style="color:#f92672">&lt;=</span> 0L)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算deadline</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> deadline <span style="color:#f92672">=</span> System.<span style="color:#a6e22e">nanoTime</span>() <span style="color:#f92672">+</span> nanosTimeout;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将node添加到队列中</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Node node <span style="color:#f92672">=</span> addWaiter(Node.<span style="color:#a6e22e">EXCLUSIVE</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">predecessor</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire(arg)) {
</span></span><span style="display:flex;"><span>                setHead(node);
</span></span><span style="display:flex;"><span>                p.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// help GC</span>
</span></span><span style="display:flex;"><span>                failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 计算剩余时间</span>
</span></span><span style="display:flex;"><span>            nanosTimeout <span style="color:#f92672">=</span> deadline <span style="color:#f92672">-</span> System.<span style="color:#a6e22e">nanoTime</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果小于0说明计时结束，获取失败</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nanosTimeout <span style="color:#f92672">&lt;=</span> 0L)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断是否需要阻塞，区别在于该方法阻塞了指定了时长</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 为什么剩余时间要大于spinForTimeoutThreshold(1000)才会阻塞</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 说明此时剩余时间非常短，没必要再执行挂起操作了，不如直接执行下一次循环</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                nanosTimeout <span style="color:#f92672">&gt;</span> spinForTimeoutThreshold)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 调用lockSupport park指定时长</span>
</span></span><span style="display:flex;"><span>                LockSupport.<span style="color:#a6e22e">parkNanos</span>(<span style="color:#66d9ef">this</span>, nanosTimeout);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// park过程中被中断直接抛出异常</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (Thread.<span style="color:#a6e22e">interrupted</span>())
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InterruptedException();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (failed)
</span></span><span style="display:flex;"><span>            cancelAcquire(node);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>相比lockInterruptibly方法，tryLock(time)除了响应中断外，还拥有超时控制，由LockSupport.parkNanos()实现。</p>
</blockquote>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">其他文章</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://blog.leejay.top/post/concurrent_condition/">
                <span class="button__icon">←</span>
                <span class="button__text">Condition源码解析</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="https://blog.leejay.top/post/concurrent_cas/">
                <span class="button__text">CAS乐观锁浅析</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span><a rel="nofollow" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备18050258号-1</a></span>
    
        
      </div>
  </div>
</footer>

<script src="https://blog.leejay.top/assets/main.js"></script>
<script src="https://blog.leejay.top/assets/prism.js"></script>






  
</div>

</body>
</html>
