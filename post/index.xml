<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Keep Improving</title>
    <link>https://leejay.top/post/</link>
    <description>Recent content in Posts on Keep Improving</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>苏ICP备18050258号-1</copyright>
    <lastBuildDate>Fri, 17 Mar 2023 15:43:00 +0800</lastBuildDate><atom:link href="https://leejay.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java虚拟机概述</title>
      <link>https://leejay.top/post/jvm_in_action/</link>
      <pubDate>Tue, 14 Feb 2023 14:58:25 +0800</pubDate>
      
      <guid>https://leejay.top/post/jvm_in_action/</guid>
      <description>1. 类加载流程 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
1.1 类加载时机 类加载的生命周期 类型被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期经历如上七个阶段。
其中验证、准备、解析统称为连接。
需要注意的是：解析阶段顺序是不确定的，它可以在初始化阶段之后再开始。
类初始化的六种情况 《Java虚拟机规范》中规定了六种要立即对类进行”初始化“(加载、验证、准备自然需要在此之前执行)的情况：
遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，类型没有过初始化，生成这四条字节码指令的场景有：
使用new关键字实例化对象。 // 会初始化A A a = new A(); 读取或设置一个类型的静态字段(final修饰、编译器进入常量池的静态字段除外)。 class B { // 会导致A类被初始化 static A a = new A(); public static void main(String[] args) { // 不会导致A类被初始化 System.out.print(A.HELLO_WORLD); } } class A { static final String HELLO_WORLD = &amp;#34;hello_world&amp;#34;; } 引用静态字符串常量不会导致持有该常量的类初始化。
调用一个类型的静态方法 class A { static void print() { System.out.print(&amp;#34;hello&amp;#34;); } public static void main(String[] args) { A.</description>
    </item>
    
    <item>
      <title>Kmp算法浅析</title>
      <link>https://leejay.top/post/algorithm_kmp/</link>
      <pubDate>Wed, 08 Jun 2022 15:52:15 +0800</pubDate>
      
      <guid>https://leejay.top/post/algorithm_kmp/</guid>
      <description>KMP算法：一种字符串搜索算法。是第一个用于字符串匹配的线性时间算法。
暴力匹配 在字符串匹配中，若我们使用暴力破解对主串和子串进行匹配，当匹配失败就回退到主串的下一个字符重新开始匹配。在最坏的情况下，此种方式的时间复杂度为O(m*n)。匹配流程下图所示。
KMP算法 基本概念 KMP算法（由Knuth、Morris、Pratt三人共同发表），其特点就是在一次字符串的遍历过程中就可以匹配出子串。其时间复杂度是O(m+n)。
KMP算法中的核心概念就是基于最大公共前后缀生成next数组，在匹配失败的时候避免了暴力算法中的回退所带来的高时间复杂度问题。
在理解KMP算法的核心概念最大公共前后缀之前，我们需要先明白前缀和后缀的含义。
前缀：在字符串中除了最后一个字符外，所有以第一个字符开始的连续子串。
后缀：在字符串中除了第一个字符外，所有以最后一个字符结尾的连续子串。
由此可以得出最大公共前后缀：在字符串里所有前缀和后缀相等的子串中最长的那个(不能超过字符串长度)。
graph LR A(&#34;ABAA&#34;) A --&gt; B(&#34;最大前缀: ABA&#34;) A --&gt; C(&#34;最大后缀: BAA&#34;) A --&gt; D(&#34;最大公共前后缀: A&#34;) 基于最大公共前后缀生成的next数组就是用于记录子串中不同位置的最大公共前后缀长度。也就是当匹配失败的时候，子串需要回退的位置。那么next数组是如何计算的呢？参考下图手算next数组流程。
next数组的第一位默认是-1，即当匹配失败的时候，子串往后移动一位继续匹配。 next数组的作用：若子串的第n个位置的与主串不匹配，那么需要将子串回退到next[n]的位置再次进行匹配。 计算next[n]最大公共前后缀的子串范围是$P_0P_1&amp;hellip;P_{n-1}$。 代码推导 next数组推导 若计算next[i+1]的值时，必然已经知道next[i]的值（类似动态规划）。 假设next[i]=k，根据最大公共前后缀定义，那么此时必有：$C_0C_1&amp;hellip;C_{k-1}=C_{i-k}&amp;hellip;C_{i-1}$。 若$C_k=C_i$，则 $next[i+1] = k + 1$。 若$C_k != C_i$, 若 $next[k] = z$，根据最大公共前后缀定义，此时必有：$C0&amp;hellip;C_{z-1} = C_{k-z}&amp;hellip;C_{k-1} = C_{i-k}&amp;hellip;C_{i-k+z-1} = C_{i-z}&amp;hellip;C_{i-1}$，结合第二步的结果可得：$C0&amp;hellip;C_{z-1} = C_{i-z}&amp;hellip;C_{i-1}$。 若$ C_{k-z} = C_{i} $，那么 $ next[i+1] = z + 1$。如果不相等则重复上述流程，直到最长公共前后缀的值为0就停止循环查找。 private static int[] getNext(char[] array) { final int length = array.</description>
    </item>
    
    <item>
      <title>Raspberrypi搭建指南</title>
      <link>https://leejay.top/post/raspberrypi/</link>
      <pubDate>Fri, 17 Mar 2023 15:43:00 +0800</pubDate>
      
      <guid>https://leejay.top/post/raspberrypi/</guid>
      <description>前置工作 安装系统 使用Raspberry Pi Imager来烧录系统，这个工具是树莓派官网推荐烧录工具，内置了系统镜像下来，树莓派4B推荐使用64位系统。同时高级设置中支持设置账户密码（账户默认是pi，密码不设置默认为raspberry）和wifi密码，设置完成等待烧录完毕即可。
查找树莓派ip 使用Advanced IP Scanner工具来实现局域网ip扫描，通过制造商来筛选出ip地址。
开启root账户 # 输入root密码 sudo passwd root # 解锁root账户 sudo passwd --unlock root # 如果没安装ssh sudo apt install ssh # 如果出现password expiry information changed提示 # 修改sshd_config中的PermitRootLogin without-password为PermitRootLogin yes sudo vi /etc/ssh/sshd_config # 重启后使用root登陆 reboot 修改ubuntu镜像源 vi /etc/apt/sources.list deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse deb https://mirrors.</description>
    </item>
    
    <item>
      <title>Elasticsearch操作文档</title>
      <link>https://leejay.top/post/elasticsearch/</link>
      <pubDate>Thu, 09 Feb 2023 14:17:55 +0800</pubDate>
      
      <guid>https://leejay.top/post/elasticsearch/</guid>
      <description>前置知识 Elasticsearch是一个分布式，RESTful风格的搜索和数据分析引擎。
概念点 ES是面向文档的，文档是最小单位，对应着关系型数据库中的一条数据。 index索引除了存储所有映射类型的字段，还包含一些设置，ex: refresh_interval（新增文档对于搜索可见的时间间隔，准实时）。 集群由n个节点（n≥1）组成，节点由m个分片（m≥1）组成。索引由x个主分片（x≥1）和y个副本分片（y≥0）组成。（副本可以在运行时增加，而主分片不行，在创建索引前必须决定其数量） 新增文档时，会根据文档的id进行hash计算确认一个主分区A（shard_num = hash(_id) % 主分片个数），如果A分区不在当前节点，那么ES会将文档索引到A分区所在的目标节点上，并同步到非目标节点的主分片中，并通过各节点的主分片与副本分片进行同步。 RESTful ES的查询会涉及到RESTful的相关概念
其中GET、HEAD、PUT、DELETE是幂等的操作（即任意多次执行所产生的影响均与一次执行的影响相同） POST不是幂等的操作（即每次调用都会创建一个新的资源，但实际会通过数据库主键或其他方式进行限制）。PATCH也不是幂等的，因为相比PUT对资源的全部更新，PATCH强调的是部分更新，如果是依赖于当前值的++操作，那么必定是非幂等的。 GET、HEAD是安全的操作，仅仅是查询资源并不会修改资源，PUT、PATHC、DELETE、POST是不安全的操作，会修改资源数据。 type移除 ES中的index、type、document、field分别对应着关系型数据库中的database、table、row、column，在ES8.0版本中已经不在支持type。
在es中同一个index中不同的type是存储在同一个lucene索引文件中的，不同type中相同名字的字段的含义必须相同。
但关系型数据库中的table是独立存储的，所以type在es中的用途就十分有限。
环境搭建 docker部署 # 基于docker部署es7.8.0 mkdir -p /root/es/plugins /root/es/data /root/es/config &amp;amp;&amp;amp; touch /root/es/config/elasticsearch.yml &amp;amp;&amp;amp; chmod 777 /root/es/** docker run -d --name es -p 9200:9200 -p 9300:9300 \ -v /root/es/data:/usr/share/elasticsearch/data \ -v /root/es/plugins:/usr/share/elasticsearch/plugins \ -v /root/es/conig/elasticsearch.yml:/usr/share/elasticsearch/conig/elasticsearch.yml \ -e &amp;#34;discovery.type=single-node&amp;#34; \ -e &amp;#34;ES_JAVA_OPTS=-Xms512m -Xmx512m&amp;#34; \ docker.io/library/elasticsearch:7.8.0 配置分词器 # 配置分词器 wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.8.0/elasticsearch-analysis-ik-7.8.0.zip \ &amp;amp;&amp;amp; mkdir -p ik/ &amp;amp;&amp;amp; unzip -od ik/ elasticsearch-analysis-ik-7.</description>
    </item>
    
    <item>
      <title>Java中的小知识点</title>
      <link>https://leejay.top/post/knowledge/</link>
      <pubDate>Thu, 12 May 2022 17:55:10 +0800</pubDate>
      
      <guid>https://leejay.top/post/knowledge/</guid>
      <description>&lt;h2 id=&#34;1-java是值传递还是引用传递&#34;&gt;1. Java是值传递还是引用传递&lt;/h2&gt;
&lt;p&gt;结论： Java只有值传递没有引用传递。&lt;/p&gt;
&lt;p&gt;值传递与引用传递的区别：&lt;code&gt;对形参的修改不会影响到实参被称为值传递。引用传递则相反。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;change&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Integer i&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;change&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Person person&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;李四&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Integer x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    change&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// x = 1;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Person person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Person&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    change&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;person&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;李四&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果是基本数据类型，是将数据复制一份传递给方法，自然不会影响。&lt;/li&gt;
&lt;li&gt;如果是对象做参数时，将堆中对象的引用复制一份传递给方法，&lt;code&gt;引用的地址不会被修改（也是被称为值传递的根本原因&lt;/code&gt;)，但是地址的内容会被函数修改。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-包装类integer中的缓存池&#34;&gt;2. 包装类Integer中的缓存池&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; y&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Integer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer w &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Integer&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;z &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; w&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Integer类型的缓存池的范围是&lt;code&gt;[-128, 127]&lt;/code&gt;，只要是这个范围的值自动装箱就会返回相同的对象。&lt;/li&gt;
&lt;li&gt;Integer类型中的equals()方法是对&lt;code&gt;包装的值&lt;/code&gt;进行了比较，而不是比较对象。&lt;/li&gt;
&lt;li&gt;valueOf()方法利用了缓存，符合第一条的规则。&lt;/li&gt;
&lt;li&gt;如果通过new关键字创建对象，是没用利用缓存，并不符合第一条规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-多层嵌套循环跳出问题&#34;&gt;3. 多层嵌套循环跳出问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;c中可以通过goto语句跳出多层嵌套循环，java保留了goto关键字，但没有任何作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]{&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]{&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        loop_a:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; loop_a&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 跳出最外层循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; -&amp;gt; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 1 -&amp;gt; 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;------------------------&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        loop_b&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt; loop_b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 跳过内层循环值为5的，继续从外层的下一个数开始执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; -&amp;gt; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 1 -&amp;gt; 4; 2 -&amp;gt; 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;4-string对象的创建&#34;&gt;4. String对象的创建&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串常量池（String Common Pool）：因为字符串的大量创建会影响程序的性能，JVM引入了&lt;code&gt;字符串常量池&lt;/code&gt;来减少字符串性能的开销（也基于字符串的不可变性才能实现）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; String&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;intern&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;intern&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//  false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//  true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//  true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; e&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//  true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;字面量创建对象&#34;&gt;字面量创建对象&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://image.leejay.top/img/String%E5%AD%97%E9%9D%A2%E9%87%8F.png&#34; alt=&#34;String字面量&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;new关键字创建对象&#34;&gt;new关键字创建对象&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://image.leejay.top/img/image-20220512175258152.png&#34; alt=&#34;image-20220512175258152&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;stringintern&#34;&gt;String.intern()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;当调用 intern 方法时，如果池中已经包含一个等于该String对象的字符串，&lt;code&gt;由equals(Object)方法确定&lt;/code&gt;，则返回池中的字符串。否则，将此String对象添加到池中并返回对该String对象的引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://image.leejay.top/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220512175811.png&#34; alt=&#34;微信截图_20220512175811&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在阅读Spring AOP的源码(基于Spring 5.2.8.RELEASE)中，发现&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解中的&lt;code&gt;proxyTargetClass&lt;/code&gt;参数并不如注释（&lt;code&gt;是否创建基于子类的CGLIB代理&lt;/code&gt;）中说所的哪样生效。无论我设置成true/false都会使用CGLIB代理。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Grpc快速入门</title>
      <link>https://leejay.top/post/grpc/</link>
      <pubDate>Fri, 22 Apr 2022 16:29:25 +0800</pubDate>
      
      <guid>https://leejay.top/post/grpc/</guid>
      <description>Grpc快速入门 grpc是一款高性能、开源的通用Rpc框架。由google开源，默认使用protobuf作为定义接口的语言(IDL)和底层的消息交换格式，使用Http/2作为传输协议。
Rpc简介 Rpc(remote procedure call)，即远程过程调用。服务器A上的服务想调用服务器B上的服务提供的方法，因为不存在于同一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
Rpc像调用本地方法一样去调用远程方法。
Http与Rpc Rpc是一个完整的远程调用方法，通常包括通信协议（http和tcp）和序列化协议（json、xml、protobuf等）。
Http与Tcp 为什么使用自定义tcp协议实现进程通信？
http传输协议头中包含冗余的部分，且使用了文本编码（body仍是二进制编码），非常占用字节数。使用自定义tcp协议，能够有效提升传输效率，提升性能。
Grpc与Restful Grpc Restful 消息编码 protobuf json 传输协议 Http/2 Http 传输形式 支持流式传输 不支持流式传输 Grpc概述 使用protobuf作为IDL和底层消息的交换格式。 protobuf支持多种语言，所以Grpc也是跨语言的。 客户端持有存根(Stub)提供与服务器相同的方法。 Grpc-Java 使用Java语言作为客户端和服务端的语言来演示grpc的实现。
pom配置 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;grpc-netty-shaded&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.45.1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;grpc-protobuf&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.45.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;grpc-stub&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.45.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;!-- necessary for Java 9+ --&amp;gt; &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;annotations-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;6.0.53&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;build&amp;gt; &amp;lt;extensions&amp;gt; &amp;lt;extension&amp;gt; &amp;lt;groupId&amp;gt;kr.motd.maven&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;os-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.6.2&amp;lt;/version&amp;gt; &amp;lt;/extension&amp;gt; &amp;lt;/extensions&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;excludes&amp;gt; &amp;lt;exclude&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Tinyproxy轻量代理使用教程</title>
      <link>https://leejay.top/post/tiny_proxy/</link>
      <pubDate>Fri, 15 Apr 2022 10:40:36 +0800</pubDate>
      
      <guid>https://leejay.top/post/tiny_proxy/</guid>
      <description>Tinyproxy是一个轻量级的HTTP / HTTPS代理守护进程，快速且小巧。
Tinyproxy的安装 基于Docker安装 使用monokal/tinyproxy的镜像,dockerhub上的使用已经很清楚了，按照描述:
docker run -d --name=&amp;#39;tinyproxy&amp;#39; -p &amp;lt;Host_Port&amp;gt;:8888 --env BASIC_AUTH_USER=&amp;lt;username&amp;gt; --env BASIC_AUTH_PASSWORD=&amp;lt;password&amp;gt; --env TIMEOUT=&amp;lt;timeout&amp;gt; monokal/tinyproxy:latest &amp;lt;ACL&amp;gt; Set &amp;lt;Host_Port&amp;gt; to the port you wish the proxy to be accessible from.
Set to &amp;lsquo;ANY&amp;rsquo; to allow unrestricted proxy access, or one or more space seperated IP/CIDR addresses for tighter security.
Basic auth is optional.
Timeout is optional.
curl测试 curl -x http://&amp;lt;your_username&amp;gt;:&amp;lt;your_password&amp;gt;@&amp;lt;tinyproxy_ip&amp;gt;:&amp;lt;tinyproxy_port&amp;gt; http://httpbin.org/ip 如果代理需要用户名密码验证，但是没有传递，那么会出现407 Proxy Authentication Required提示。 如果代理的用户名密码错误，会出现Unauthorized提示。 如果访问代理的ip地址不在tinyproxy的access名单中，会出现Access denied提示。 RestTemplate中使用代理 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Java中的进制与位运算</title>
      <link>https://leejay.top/post/decimal/</link>
      <pubDate>Fri, 08 Apr 2022 14:44:27 +0800</pubDate>
      
      <guid>https://leejay.top/post/decimal/</guid>
      <description>进制详解 包括二进制、八进制、十进制和十六进制, 计算机由电路构成, 只有0/1两种状态, 所以采用的是二进制
二进制 由0 和 1组成, 计算机内部都是二进制的形式存储的。 进行加法运算的时候逢二进一, 减法运算的时候借一当二。在java中0b开头表示二进制值
十进制 由0~9的数字组成, 加法计算时逢十进一, 减法计算时借一当十。十进制是人类发展中自然形成的
八进制 由0~7的数字组成, 加法计算时逢八进一, 减法计算时借一当八。java中要求第一位是0开始
十六进制 由0~9,A(10),B(11),C(12),D(13),E(14),F(15)(不区分大小写)组成, 加法计算时逢十六进一, 减法计算时借一当十六。java中要求以0x开始
进制互相换算 二进制 -&amp;gt; 十进制 假设一个二进制是 1011(3210), 从右往左开始分别是 0、1、2、3 位, 那么它的十进制值为:
1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 =&amp;gt; 8 + 0 + 2 + 1 =&amp;gt; 13 十进制 -&amp;gt; 二进制 假设一个十进制是 13, 一种方法是除二反序取余法, 计算如下:
13/2 = 6 余 1 6/2 = 3 余 0 3/2 = 1 余 1 1/2 = 0 余 1 反序取余数值, 结果是: 1101 另一种计算如下:</description>
    </item>
    
    <item>
      <title>Kube Eventer基于mysql的使用</title>
      <link>https://leejay.top/post/kube_eventer/</link>
      <pubDate>Mon, 21 Mar 2022 15:03:59 +0800</pubDate>
      
      <guid>https://leejay.top/post/kube_eventer/</guid>
      <description>前言 工作上需要持久化Pod的事件信息，我们知道事件默认是由etcd来进行存储的，但是事件的信息存储具有时效性（默认1h，通过修改kube-apiserver的--event--ttl实现更长时间的存储），且将etcd这种内存级别的组件作为持久化数据库也是不合理的，所以使用了阿里开源的这款事件告警组件kube-eventer。
使用方法 创建表 CREATE TABLE IF NOT EXISTS `kube_event` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &amp;#39;event primary key&amp;#39;, `name` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event name&amp;#39;, `namespace` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event namespace&amp;#39;, `event_id` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event_id&amp;#39;, `type` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event type Warning or Normal&amp;#39;, `reason` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event reason&amp;#39;, `message` text NOT NULL COMMENT &amp;#39;event message&amp;#39;, `kind` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event kind&amp;#39;, `first_occurrence_time` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event first occurrence time&amp;#39;, `last_occurrence_time` varchar(64) NOT NULL DEFAULT &amp;#39;&amp;#39; COMMENT &amp;#39;event last occurrence time&amp;#39;, `cluster` varchar(64) DEFAULT NULL COMMENT &amp;#39;cluster&amp;#39;, `source` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT &amp;#39;source&amp;#39;, PRIMARY KEY (`id`), UNIQUE KEY `event_id_index` (`event_id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT=&amp;#39;Event info tables&amp;#39;; 执行yaml apiVersion: apps/v1 kind: Deployment metadata: labels: name: kube-eventer name: kube-eventer namespace: kube-system spec: replicas: 1 selector: matchLabels: app: kube-eventer template: metadata: labels: app: kube-eventer annotations:	scheduler.</description>
    </item>
    
    <item>
      <title>Mirai安装教程</title>
      <link>https://leejay.top/post/mirai/</link>
      <pubDate>Mon, 07 Mar 2022 10:21:01 +0800</pubDate>
      
      <guid>https://leejay.top/post/mirai/</guid>
      <description>&lt;h2 id=&#34;mirai&#34;&gt;Mirai&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/mamoe/mirai&#34;&gt;mirai&lt;/a&gt; 是一个在全平台下运行，提供 QQ Android 协议支持的高效率机器人库。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>ApereoCas安装与使用教程</title>
      <link>https://leejay.top/post/aperao_cas/</link>
      <pubDate>Mon, 22 Nov 2021 15:30:48 +0800</pubDate>
      
      <guid>https://leejay.top/post/aperao_cas/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;正值疫情期间，一直在家办公，年前年后一直在忙基于Apereo Cas的单点登陆相关的需求，目前已经完成了大半的工作，特此记录下Apereo Cas的安装与使用教程。&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>事务的处理机制</title>
      <link>https://leejay.top/post/transcation/</link>
      <pubDate>Mon, 06 Sep 2021 16:06:48 +0800</pubDate>
      
      <guid>https://leejay.top/post/transcation/</guid>
      <description>本地事务 本地事务是指仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。
从应用角度看，它是直接依赖于数据源本身提供的事务能力来工作的，在程序代码层面，最多只能对事务接口做一层标准化的包装（如 JDBC 接口），并不能深入参与到事务的运作过程当中，事务的操作都要依赖底层数据源的支持才能工作。
例如MySQL的Innodb引擎支持事务操作。
全局事务 被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。
X/A协议，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口。通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。
X/A是规范，JTA是X/A规范的Java实现。
两段式提交（2PC） 准备阶段 协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交（它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record ）则回复 Prepared，否则回复 Non-Prepared。
提交阶段 协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。
如果节点因为网络或其他原因处于临时失联状态，由于在准备阶段已经写入了完整的重做日志，所以当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，再而向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作。
缺点 单点问题：如果协调者宕机一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待。 性能问题：所有参与者相当于被绑定成为一个统一调度的整体，根据木桶效应，需要等待集群中最慢的那一个处理操作结束为止，导致性能较差。 一致性风险：在协调者会持久化事务状态，并提交自己的事务后，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。 三段式提交（3PC） 三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。
在三段式提交中，如果在 PreCommit 阶段之后发生了协调者宕机，即参与者没有能等到 DoCommit 的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了协调者单点问题的风险。
缺点 相比两段式提交的一致性风险更高了，因为默认无法接收到协调者的指令时，会自动提交事务，如果因为网络延时导致Abort指令被接受前就提交了事务，反而产生更严重的后果。
分布式事务 在分布式服务环境下的事务处理机制（相比全局事务单个服务的多个服务同时访问多个数据源的事务处理机制）。
CAP定理：
一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。 可用性（Availability）：代表系统不间断地提供服务的能力。 分区容错性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。 只要用到网络来共享数据，分区现象就会始终存在。放弃分区容错性只有不通过网络来实现（例如节点共享同一块磁盘）。而可用性一般是建设分布式的目的（除了银行、证券这些容忍零出错的系统）。所以一致性通常成为了被牺牲的属性。为此划分出了强一致性（即CAP中的C）和最终一致性两种类型。
最终一致性：如果数据在一段时间之内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果。
最大努力一次提交 指的就是将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式（不限于消息系统）来促使同一个分布式事务中的其他关联业务全部完成。
操作流程 应对用户账号扣款、商家账号收款、库存商品出库三个流程，根据出错概率的大小来安排它们的操作顺序。</description>
    </item>
    
    <item>
      <title>Git Command</title>
      <link>https://leejay.top/post/git_command/</link>
      <pubDate>Wed, 25 Aug 2021 16:39:56 +0800</pubDate>
      
      <guid>https://leejay.top/post/git_command/</guid>
      <description>本地仓库的操作 本地仓库提交 # 本地提交 git commit -m &amp;#34;message&amp;#34; 分支 分支的创建基于``基于某个提交及它的父提交，当前所在的分支会用*`标识
# 创建分支（分支的创建基于某个提交） git branch ${branch_name} # 切换到这个分支 git checkout ${branch_name} # 创建并切换到这个分支 git checkout -b ${branch_name} # 将source分支指向目标分支或目标版本 git branch -f &amp;lt;source_branch_name&amp;gt; &amp;lt;dest_branch_name|version num&amp;gt; # 删除指定分支 git branch [-D|-d] &amp;lt;branch_name&amp;gt; 合并 merge 将某个分支A上不被当前分支B包含的提交记录合并到当前分支B上。会在当前分支B下创建一个新的合并记录，此时分支B会包含分支A的所有提交记录。
# 将${branch_name}分支提交记录覆盖到当前分支 git merge ${branch_name} rebase 相比于merge，rebase会从当前分支和目标分支的共同父节点P开始，将当前分支P点后的提交记录都复制到目标分支的最新节点后，最终看起来就像只有一条分支（rebase后的commit id和原来不一致了）。
# 将当前分支合并到${branch_name}上 # git rebase a 会将当前分支的提交记录复制到分支a后面 git rebase [-i] ${branch_name} # 将child分支的提交记录移到parent的提交记录后 git rebase ${parent_branch} ${child_branch} HEAD HEAD 是一个对当前检出记录的符号引用，指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。</description>
    </item>
    
    <item>
      <title>Mysql学习笔记</title>
      <link>https://leejay.top/post/mysql/</link>
      <pubDate>Fri, 23 Jul 2021 09:51:37 +0800</pubDate>
      
      <guid>https://leejay.top/post/mysql/</guid>
      <description>MySQL中的字符集和比较规则 字符集 SHOW CHARSET LIKE &amp;#39;utf8_%&amp;#39;; 字符集 编码长度 ASCII（128个字符） 1字节 ISO 8859-1（256个字符，又叫latin1） 1字节 GB2312（收录6763个汉字，兼容ASCII） 字符在ASCII中采用1字节，否则2字节 GBK（对GB2312进行扩充，兼容GB2312） 与GB2312相同 Unicode（兼容ASCII字符集，采用变长编码方式） UTF-8:：1-4个字节，UTF-16：2或4字节，UTF-32：4字节 MySQL中的utf8和utf8mb4字符集区别在于前者是1-3字符（阉割），后者是1-4字符。
比较规则 SHOW COLLATION LIKE &amp;#39;utf8_%&amp;#39;; 后缀 英文 不区分重音 _ai accent insensitive 不区分重音 _as accent sensitive 区分重音 _ci case insensitive 不区分大小写 _cs case sensitive 区分大小写 _bin binary 以二进制方式比较 MySQL中utf8默认的比较规则就是utf8_general_ci。
字符集与比较规则的级别 # [服务器级别] SHOW VARIABLES LIKE &amp;#39;character_set_server&amp;#39;; SHOW VARIABLES LIKE &amp;#39;collation_server&amp;#39;; # [创建或修改数据库比较规则] CREATE[ALTER] DATABASE [database_name] CHARACTER SET utf8 COLLATE utf8_general_ci; # [数据库级别] USE [database_name]; SHOW VARIABLES LIKE &amp;#39;character_set_database&amp;#39;; SHOW VARIABLES LIKE &amp;#39;collation_database&amp;#39;; # [表级别] 如果表不设置字符集和比较规则，默认继承数据库的配置 CREATE[ALTER] TABLE unicode(name VARCHAR(10)) CHARACTER SET utf8 COLLATE utf8_general_ci; # [表级别] 查看表的字符集和编码规则 SHOW TABLE STATUS FROM unicode; # [创建列的字符集和比较规则] 不设置默认读取表的配置 CREATE TABLE line( name VARCHAR(10) CHARACTER SET utf8 COLLATE utf8_general_ci, age INT(16) ) ALTER TABLE [table_name] MODIFY [column] VARCHAR CHARACTER SET latin1 COLLATE latin1_general_cs; 无论是只修改字符集或比较规则，未设置的一方都会自动的改为与修改一方对应的配置。</description>
    </item>
    
    <item>
      <title>关于EnableAspectJAutoProxy注解引出的若干问题</title>
      <link>https://leejay.top/post/enable_aspectj_auto_proxy/</link>
      <pubDate>Wed, 12 May 2021 16:18:28 +0800</pubDate>
      
      <guid>https://leejay.top/post/enable_aspectj_auto_proxy/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在阅读Spring AOP的源码(基于Spring 5.2.8.RELEASE)中，发现&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解中的&lt;code&gt;proxyTargetClass&lt;/code&gt;参数并不如注释（&lt;code&gt;是否创建基于子类的CGLIB代理&lt;/code&gt;）中说所的哪样生效。无论我设置成true/false都会使用CGLIB代理。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Docker命令汇总</title>
      <link>https://leejay.top/post/docker/</link>
      <pubDate>Fri, 16 Apr 2021 11:02:51 +0800</pubDate>
      
      <guid>https://leejay.top/post/docker/</guid>
      <description>&lt;h2 id=&#34;docker-cp&#34;&gt;Docker cp&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 将容器内的conf.d文件夹下的所有文件复制到宿主机上/opt/nginx/conf.d文件夹下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker cp nginx:/etc/nginx/conf.d/. /opt/nginx/conf.d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 将容器内的conf.d文件夹（包含文件夹内的文件）复制到宿主及上/opt/nginx目录下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker cp nginx:/etc/nginx/conf.d  /opt/nginx/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes概念入门</title>
      <link>https://leejay.top/post/kubernetes/</link>
      <pubDate>Fri, 09 Apr 2021 11:07:57 +0800</pubDate>
      
      <guid>https://leejay.top/post/kubernetes/</guid>
      <description>容器与虚拟机的区别 虚拟机（VM）是虚拟化底层计算机，每个VM不仅需要运行操作系统的完整副本，还需要运行操作系统需要运行的所有硬件的虚拟副本。这就意味着需要大量的硬件资源。
相比VM，容器只需要虚拟化操作系统。每个容器共享主机操作系统内核。相比VM功能类似，但是开销少很多。但是VM提供了完全隔离的环境。
容器内的进程是运行在宿主机的操作系统上的，而虚拟机内的进程是运行在不同的操作系统上的，但容器内的进程是与其他进程隔离的。、
VM内的指令执行流程：VM程序指令 -&amp;gt; VM操作系统内核 -&amp;gt; 宿主机管理程序 -&amp;gt; 宿主机内核。 容器会完全指定运行在宿主机上的同一个内核的系统调用，容器间是共享操作系统内核。 容器的隔离机制实现 Linux命名空间 每个进程只能看到自己的系统视图（文件、进程、网络接口、主机名等）。进程不单单只属于一个命名空间，而是属于每个类型的一个命名空间。类型包括Mount(mnt)、Process ID(pid)、NetWork(net)、Inter-process communication(ipd)、UTS、User ID(user)。
Linux控制组 基于cgroups实现，它是Linux内核功能，限制一个进程或一组进程的资源使用不超过被分配的量。
Kubernetes基本概念 Kubernetes Master &amp;amp; Node Kubernetes运行流程 在应用程序运行时，可以增加或减少副本数量。也可以交由kubernetes进行判断。 kubernetes可能需要在集群中迁移你的容器，比如运行的节点失败时、为其他容器腾空间从节点移除时。 Docker Command # 运行容器并输出hello world docker run busybox echo hello world Dockerfile const http = require(&amp;#39;http&amp;#39;); const os = require(&amp;#39;os&amp;#39;); console .log (&amp;#34;Kub i a server starting ... &amp;#34;); var handler = function(request, response){ console.log (&amp;#34;Rece i ved request from ” + request connection.</description>
    </item>
    
    <item>
      <title>HashMap的几点注意事项</title>
      <link>https://leejay.top/post/hashmap/</link>
      <pubDate>Wed, 07 Apr 2021 11:03:14 +0800</pubDate>
      
      <guid>https://leejay.top/post/hashmap/</guid>
      <description>HashMap的几点注意事项 数组的创建时机 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 省略代码 } static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4 final Node&amp;lt;K,V&amp;gt;[] resize() { // 省略代码 else { // 初始容量16 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap]; // 省略代码 return newTab; } static final float DEFAULT_LOAD_FACTOR = 0.</description>
    </item>
    
    <item>
      <title>Spring Security基础入门</title>
      <link>https://leejay.top/post/spring_security_in_action/</link>
      <pubDate>Fri, 19 Mar 2021 17:47:21 +0800</pubDate>
      
      <guid>https://leejay.top/post/spring_security_in_action/</guid>
      <description>Spring Security入门 依赖与配置 maven依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Spring Security配置 @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { /** * 自定义用户管理系统 */ @Bean public UserDetailsManager userDetailsManager() { UserManager userManager = new UserManager(); userManager.createUser(innerUser()); return userManager; } private UserDetails innerUser() { // load user by username 模拟从数据库获取用户权限等信息 List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;(); // 添加 ADMIN &amp;amp; USER 权限 authorities.add(new SimpleGrantedAuthority(&amp;#34;USER&amp;#34;)); authorities.add(new SimpleGrantedAuthority(&amp;#34;ADMIN&amp;#34;)); // 一般数据库用户密码存入时会先加密，此处只是模拟加密后的用户信息 // 使用UserDetails.User$UserBuilder构建user return User.withUsername(&amp;#34;jack&amp;#34;) .</description>
    </item>
    
    <item>
      <title>Redis基础入门</title>
      <link>https://leejay.top/post/redis_in_action/</link>
      <pubDate>Thu, 28 Jan 2021 11:10:39 +0800</pubDate>
      
      <guid>https://leejay.top/post/redis_in_action/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;基于内存存储的&lt;code&gt;非关系型&lt;/code&gt;数据库，支持五种数据结构，并支持&lt;code&gt;发布与订阅&lt;/code&gt;、&lt;code&gt;主从复制&lt;/code&gt;、&lt;code&gt;持久化&lt;/code&gt;等功能。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Linux下cron定时器</title>
      <link>https://leejay.top/post/linux_cron/</link>
      <pubDate>Thu, 07 Jan 2021 14:21:38 +0800</pubDate>
      
      <guid>https://leejay.top/post/linux_cron/</guid>
      <description>&lt;h3 id=&#34;crontab命令&#34;&gt;crontab命令&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;crontab&lt;/code&gt;是linux下的定时任务服务，是基于&lt;code&gt;cron表达式&lt;/code&gt;实现定时任务操作。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Shell启动服务</title>
      <link>https://leejay.top/post/linux_shell/</link>
      <pubDate>Tue, 29 Dec 2020 18:29:04 +0800</pubDate>
      
      <guid>https://leejay.top/post/linux_shell/</guid>
      <description>__dir__=/www/server/code/service-platform __web__=ruoyi-web __admin__=ruoyi-admin __app__=(&amp;#34;$__web__&amp;#34; &amp;#34;$__admin__&amp;#34;) # 使用说明，用来提示输入参数 usage() { echo &amp;#34;Usage: sh deploy.sh [start|stop|restart|status]&amp;#34; exit 1 } pull() { cd $__dir__ git pull echo &amp;#34;git pull code success&amp;#34; } build_parent() { mvn clean install -Dmaven.test.skip=true -f $__dir__/pom.xml } build_module() { mvn clean package -Dmaven.test.skip=true -f $__dir__/$1/pom.xml echo &amp;#34;############# $1 Build success #############&amp;#34; } is_exist() { pid=$(ps -ef | grep $1 | grep -v grep | awk &amp;#39;{print $2}&amp;#39;) #如果不存在返回1，存在返回0 if [ -z &amp;#34;${pid}&amp;#34; ]; then return 1 else return 0 fi } backup() { __jar__=$1-$2.</description>
    </item>
    
    <item>
      <title>Netty框架入门</title>
      <link>https://leejay.top/post/netty/</link>
      <pubDate>Mon, 14 Dec 2020 17:58:49 +0800</pubDate>
      
      <guid>https://leejay.top/post/netty/</guid>
      <description>Netty OIO：最开始表示为旧的输入/输出（Old I/O），后又可以理解为阻塞输入/输出（Block I/O）。
NIO：最开始表示为新的输入/输出（New I/O），后又可以理解为非阻塞输入/输出（Non-Block I/O）。
核心组件 组件概览 Channel 基于Socket的进一步封装，降低了Socket的复杂度。包含众多的实现：NioSocketChannel、NioServerSocketChannel等。
EventLoop Netty的核心抽象，用于处理连接的生命周期中所发生的事件。
一个EventLoopGroup包含一个或多个EventLoop。 一个EventLoop在其生命周期中只和一个Thread绑定。该EventLoop处理的I/O都在该Thread上被处理。 一个Channel在其生命周期中只会被注册到一个EventLoop中。 一个EventLoop可以被分配个一个或多个Channel。 EventLoop执行任务时，会先判断当前执行任务的线程是否是当前EventLoop的绑定线程，不是则入队等待下一次处理。 bootstrap.handle(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { // 通过channel绑定的eventLoop来实现调度任务 ch.eventLoop().scheduleAtFixedRate( () -&amp;gt; log.info(&amp;#34;do something ...&amp;#34;), 1L, 1L, TimeUnit.SECONDS); }); 使用Channel绑定的EventLoop实现定时任务调度。
ChannelFuture 因为Netty的操作都是异步的，基于Future的ChannelFuture的接口，添加ChannelFutureListener来实现某个操作完成时被通知。
同属于一个channel的操作都会被保证以它们被调用的顺序来执行。
ChannelHandler 用于处理所有进出站的数据的事件处理器。实现类包括ChannelInboundHandler、ChannelOutboundHandler。
public interface ChannelHandler {} public interface ChannelInboundHandler extends ChannelHandler {} public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {} public abstract class SimpleChannelInboundHandler&amp;lt;I&amp;gt; extends ChannelInboundHandlerAdapter {} ChannelPipeline 用于存储ChannelHandler链的容器。在应用程序初始化时（BootStrap引导）通过ChannelInitializer将自定义的ChannelHandler注册到ChannelPipeline中。</description>
    </item>
    
    <item>
      <title>SpringMVC使用注意</title>
      <link>https://leejay.top/post/spring_mvc/</link>
      <pubDate>Tue, 10 Nov 2020 11:04:59 +0800</pubDate>
      
      <guid>https://leejay.top/post/spring_mvc/</guid>
      <description>SpringMVC相关问题 拦截器中@value注解不生效 原因在于：当我们继承WebMvcConfigurationSupport中的addInterceptors方法，并添加自定义的拦截器时，如果我们使用new的方式创建，那么该拦截器不会被IOC容器管理，所以无法给通过@value注解注入配置，推荐@Bean注解注入。
public class LoginInterceptor implements HandlerInterceptor { private final Logger log = LoggerFactory.getLogger(this.getClass()); @Override public boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(&amp;#34;request is coming in ...&amp;#34;); return false; } } public class SpringCloudEurekaServerApplication implements WebMvcConfigurer { @Bean public LoginInterceptor loginInterceptor() { return new LoginInterceptor(); } @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginInterceptor()).addPathPatterns(&amp;#34;/**&amp;#34;); } } WebMvcConfigurer 和 WebMvcConfigurationSupport 存在WebMvcConfigurationSupport则WebMvcConfigurer不生效 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) @ConditionalOnMissingBean(WebMvcConfigurationSupport.</description>
    </item>
    
    <item>
      <title>二叉堆时间复杂度分析</title>
      <link>https://leejay.top/post/algorithm_binary_dump/</link>
      <pubDate>Sat, 01 Aug 2020 11:10:01 +0800</pubDate>
      
      <guid>https://leejay.top/post/algorithm_binary_dump/</guid>
      <description>二叉堆概念 二叉堆本质上是一颗完全二叉树，它的根节点又叫做堆顶。二叉堆分为：
最大堆：最大堆的任何一个父节点的值，都大于或等于它左、右节点的值。
最小堆：最小堆的任何一个父节点的值，都小于或等于它左、右节点的值。
根据定义可以推导出，二叉堆的堆顶存放的是这棵树的最大或最小元素。
我们采用数组(物理结构)构建二叉堆(逻辑结构)，二叉堆的元素满足以下特性：
假设父节点的index为0(记为i=0)，那么它的左子节点index为2n + 1，右子节点index为2n + 2。
同样，如果当前节点的index=0，那么它的父节点index为(i-1)/2 或 (i-2)/2，取决于i % 2 == 0是否成立。
Java中的PriorityBlockingQueue底层就是使用最小二叉堆的逻辑结构实现的。
二叉堆推导 构建 对于二叉堆的构建，我们选择最小二叉堆推导，对于最小二叉堆构建存在两种思路：
我们从数组队尾开始遍历，将当前元素和它的所有父爷节点比较交换，直到当前元素的最顶层父节点。直到数组遍历完毕。 // 计算当前index的父节点index int prev(int c) { return c % 2 != 0 ? (c - 1) &amp;gt;&amp;gt;&amp;gt; 1 : (c - 2) &amp;gt;&amp;gt;&amp;gt; 1; } private int[] build(int[] array) { // 计算队尾节点index int last = array.length - 1; // 从队尾开始往前比较,队首不需要比较 for (int i = last; i &amp;gt; 0; i--) { int c = i; int p = prev(c); // 如果当前节点小于父节点，那么继续循环比较 while (array[c] &amp;lt; array[p]) { // 交换位置和index int temp = array[p]; array[p] = array[c]; array[c] = temp; c = p; p = prev(c); // 跳出循环的条件:parentIndex&amp;lt;0 if (p &amp;lt; 0) { break; } } } return array; } 该方法时间复杂度：我们假设数组有n个元素，那么一共需要判断n-1个元素，每个元素最多交换logn次(即树高度)，所以时间复杂度为：O(nlogn)。</description>
    </item>
    
    <item>
      <title>Future源码解析</title>
      <link>https://leejay.top/post/concurrent_future/</link>
      <pubDate>Sun, 19 Jul 2020 17:11:13 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_future/</guid>
      <description>Future public interface Future&amp;lt;V&amp;gt; { // 获取任务结果 V get() throws InterruptedException, ExecutionException; // 获取任务结果，带超时机制 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; // 任务是否完成 boolean isDone(); // 任务是否取消 boolean isCancelled(); // 取消任务 boolean cancel(boolean mayInterruptIfRunning); } ThreadPoolExecutor中的submit方法是由他的父类AbstractExecutorService实现的
public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) { if (task == null) throw new NullPointerException(); // 封装callable对象 RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task); // 再调用线程池的execute方法 execute(ftask); // 返回FutureTask return ftask; } // 将callable作为参数传入FutureTask对象 protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) { return new FutureTask&amp;lt;T&amp;gt;(callable); } FutureTask 类的继承结构 public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; { } public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; { void run(); } FutureTask实现了RunnableFuture，而RunnableFuture继承了Runnable和Future。那么FutureTask即拥有Runnable特性，可以配合线程池执行，又拥有了Future特性，可以获取执行结果。</description>
    </item>
    
    <item>
      <title>ThreadPool线程池源码解析</title>
      <link>https://leejay.top/post/concurrent_thread_pool/</link>
      <pubDate>Fri, 17 Jul 2020 17:01:26 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_thread_pool/</guid>
      <description>ThreadPool 为什么使用线程池 我们知道频繁的单独创建线程是很消耗系统资源的，而线程池中线程是可以线程复用的，不需要每次执行都重新创建，并且线程池可以提供控制线程个数等资源限制和管理的手段。
实现原理 所谓线程池实现原理：调用方不断向线程池中添加任务，线程池中有一组线程，不断的从队列中取任务。典型的生产者和消费者模型。基于这样的原理，我们实现线程池需要使用到阻塞队列，避免无任务时轮询带来的资源消耗。
线程池类继承体系 ThreadPoolExecutor和ScheduledExecutorService是需要关注的两个核心类，前者是线程池的具体实现，后者除了能实现线程池的基本功能，还可以提供周期性执行任务功能。
任何需要线程池执行的任务，都必须直接或间接的实现Runnable接口。
ThreadPoolExecutor 构造 // 阻塞队列，具体实现由构造函数决定 private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue; private volatile int corePoolSize; private volatile int maximumPoolSize; private volatile long keepAliveTime; // 线程工厂，用于定义创建线程的方式，主要是定义线程name等相关参数 private volatile ThreadFactory threadFactory; // 拒绝策略有4种内置的策略 private volatile RejectedExecutionHandler handler; // 参数最多的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize || keepAliveTime &amp;lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码浅析</title>
      <link>https://leejay.top/post/concurrent_hash_map/</link>
      <pubDate>Tue, 14 Jul 2020 16:58:36 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_hash_map/</guid>
      <description>ConcurrentHashMap JDK1.8之后采用的是数组 + 链表 + 红黑树的结构，通过Synchronized + CAS实现线程安全，而JDK1.7采用的是将一个HashMap分成多个Segment的方式，通过继承ReentrentLock的Segment分段锁实现线程安全。
Node // Node数组，组成ConcurrentHashMap的主要结构 transient volatile Node&amp;lt;K,V&amp;gt;[] table; // 扩容期间不为null，因为存在协助扩容的机制，所以需要设置volatile保证线程间可见性 private transient volatile Node&amp;lt;K,V&amp;gt;[] nextTable; static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; { final int hash; final K key; volatile V val; volatile Node&amp;lt;K,V&amp;gt; next; Node(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) { this.hash = hash; this.key = key; this.val = val; this.next = next; } } // 如果一个index下所有的节点全部转移完后会放置ForwardingNode节点，防止put插入错误位置 // 如果正在扩容但是put插入的位置不是ForwardingNode还是可以继续put的，支持两者并发 // 如果是get的方法，那么就需要获取nextTable属性(新的chm的引用)，用于返回新的值 static final class ForwardingNode&amp;lt;K,V&amp;gt; extends Node&amp;lt;K,V&amp;gt; { final Node&amp;lt;K,V&amp;gt;[] nextTable; ForwardingNode(Node&amp;lt;K,V&amp;gt;[] tab) { super(MOVED, null, null, null); this.</description>
    </item>
    
    <item>
      <title>ConcurrentLinkedQueue源码浅析</title>
      <link>https://leejay.top/post/concurrent_linked_queue/</link>
      <pubDate>Sat, 11 Jul 2020 14:53:34 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_linked_queue/</guid>
      <description>ConcurrentLinkedQueue 特性 基于链表的无界线程安全队列。 队列顺序是FIFO先进先出的顺序。队首是插入最久的元素，队尾是最新的元素。 使用场景：许多线程将共享对一个公共集合的访问，不支持null。 内部的并发操作通过自旋 + CAS实现。与LinkedBlockingQueue独占锁不同。 构造 public class ConcurrentLinkedQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt; implements Queue&amp;lt;E&amp;gt;, java.io.Serializable { // head头节点 private transient volatile Node&amp;lt;E&amp;gt; head; // tail尾节点 private transient volatile Node&amp;lt;E&amp;gt; tail; // 不用传递初始容量 public ConcurrentLinkedQueue() { // 初始化head和tail，哨兵节点 head = tail = new Node&amp;lt;E&amp;gt;(null); } // 私有静态内部类，用于构成链表的节点（单向链表） // 核心是通过CAS来实现并发操作 private static class Node&amp;lt;E&amp;gt; { volatile E item; // 标记next节点 volatile修饰的 volatile Node&amp;lt;E&amp;gt; next; // 构造 Node(E item) { // CAS添加item UNSAFE.</description>
    </item>
    
    <item>
      <title>CopyOnWriteArrayList源码解析</title>
      <link>https://leejay.top/post/concurrent_copy_on_write_arraylist/</link>
      <pubDate>Wed, 08 Jul 2020 11:50:04 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_copy_on_write_arraylist/</guid>
      <description>CopyOnWriteArrayList CopyOnWrite思想是计算机程序设计领域的一种优化策略。若有多个调用者同时要求相同的资源，他们会获得共同的指针指向相同的资源，直到某个调用者试图修改资源的时候，才会复制一份副本给该调用者，但其他调用者见到的最初资源不改变，此过程对其他调用者透明。
CopyOnWriteArrayList是ArrayList的线程安全变体，通过生成新的副本来实现。
构造 public class CopyOnWriteArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable { // 内部独占锁 final transient ReentrantLock lock = new ReentrantLock(); // volatile 修饰的数组，只能getArray和setArray操作 private transient volatile Object[] array; // 返回当前数组 final Object[] getArray() { return array; } // 设置数组 final void setArray(Object[] a) { array = a; } // 构造函数 创建一个空数组 public CopyOnWriteArrayList() { setArray(new Object[0]); } } 底层是通过数组实现，数组使用volatile修饰保证了多线程之间的可见性。
add public boolean add(E e) { // 获取独占锁 final ReentrantLock lock = this.</description>
    </item>
    
    <item>
      <title>BlockingDeque双端阻塞队列源码浅析</title>
      <link>https://leejay.top/post/concurrent_blocking_deque/</link>
      <pubDate>Mon, 06 Jul 2020 19:20:56 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_blocking_deque/</guid>
      <description>BlockingDeque 双端队列，支持在队列的头尾出增加或获取数据，Deque接口中定义了相关的方法
public interface Deque&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt; { // 添加到队首 void addFirst(E e); // 添加到队尾 void addLast(E e); // 获取队首 boolean offerFirst(E e); // 获取队尾 boolean offerLast(E e); ... }	相比BlockingQueue的父接口Queue，Deque中定义了头尾操作数据的方法。
public interface BlockingDeque&amp;lt;E&amp;gt; extends BlockingQueue&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt; { void putFirst(E e) throws InterruptedException; void putLast(E e) throws InterruptedException; E takeFirst() throws InterruptedException; E takeLast() throws InterruptedException; ... } BlockingQueue继承了BlockingQueue和Deque接口。添加了一些抛出中断的方法。
LinkedBlockingDeque 我们以LinkedBlockingDeque为切入点了解双端队列的实现。
构造 public class LinkedBlockingDeque&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt; implements BlockingDeque&amp;lt;E&amp;gt;, java.io.Serializable { // 内部维护的静态内部类是双向节点 static final class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; prev;// 区别 Node&amp;lt;E&amp;gt; next; Node(E x) { item = x; } } // (first == null &amp;amp;&amp;amp; last == null) || // (first.</description>
    </item>
    
    <item>
      <title>BlockingQueue单向阻塞队列源码解析</title>
      <link>https://leejay.top/post/concurrent_blocking_queue/</link>
      <pubDate>Sat, 04 Jul 2020 20:38:54 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_blocking_queue/</guid>
      <description>BlockingQueue 概念 BlockingQueue带阻塞功能的线程安全队列，但队列已满时会阻塞添加者，当队列为空时会阻塞获取者。它本身是一个接口，具体的功能由它的实现类来完成。
接口方法 public interface BlockingQueue&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt; { // 添加元素到队列中返回boolean，队列满抛出异常 boolean add(E e); // 添加元素到队列中，无返回值，抛出中断异常，队列满就阻塞 void put(E e) throws InterruptedException; // 添加元素返回boolea 队列满就返回false，非阻塞 boolean offer(E e); // 添加元素返回boolean，等待指定时间直到队列有空间可插入 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; // 从队首获取元素并删除，阻塞，支持等待时中断异常 E take() throws InterruptedException; // 获取队首元素并删除，若无元素等待执行时长，时间到还没有就返回null E poll(long timeout, TimeUnit unit) throws InterruptedException; // 返回理想状态下队列不阻塞可加入的元素数量，如果队列没有最大限制就返回 // Integer.max_value int remainingCapacity(); // 移除指定元素（1个或多个）若它存在(equals比较) // 若元素存在（或队列改变）返回true boolean remove(Object o); // 判断队列是否至少包含一个某元素 public boolean contains(Object o); // 移除队列中全部可用元素，添加到指定集合中，若元素添加失败可能导致元素不在 // 移除前和添加后的集合中 int drainTo(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>StampedLock读写锁源码浅析</title>
      <link>https://leejay.top/post/concurrent_stamped_lock/</link>
      <pubDate>Wed, 01 Jul 2020 10:32:01 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_stamped_lock/</guid>
      <description>JDK1.8新增的并发工具，回顾之前的ReentrentReadWriteLock，它是悲观锁的实现：只要有线程获取了读锁，获取写锁的线程就需要等待，但有可能导致写锁无限等待（其中使用了apparentlyFirstQueuedIsExclusive方法一定概率降低了写锁无限等待的问题）。
而StampedLock是乐观锁的实现，乐观读的时候不加锁，读取后发现数据改变了再升级为悲观读，此时与写互斥。
@Slf4j public class StampedLockTest { private static final StampedLock LOCK = new StampedLock(); private static int x, y; static void add() { long stamp = LOCK.writeLock(); try { x += 1; y += 1; } finally { LOCK.unlockWrite(stamp); } } static void print() { // 尝试乐观读 long stamp = LOCK.tryOptimisticRead(); int currentX = x， currentY = y; // 如果stamp修改了，这时再加悲观读锁 if (!LOCK.validate(stamp)) { log.info(&amp;#34;value has changed ...&amp;#34;); stamp = LOCK.</description>
    </item>
    
    <item>
      <title>CyclieBarrier源码解析</title>
      <link>https://leejay.top/post/concurrent_cyclic_barrier/</link>
      <pubDate>Mon, 29 Jun 2020 13:27:36 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_cyclic_barrier/</guid>
      <description>CyclicBarrier 基于CountDownLatch的特性：计数器为0时，即使调用await，该线程也不会等待其他线程执行完毕而被阻塞。
CyclicBarrier的出现是为了解决复杂场景CountDownLatch使用的劣势。
CountDownLatch中存在两种类型的线程：分别是调用await方法和调用countDown方法的线程。
而CyclicBarrier中只存在一种线程：调用await的线程扮演了上述两种角色，即先countDown后await。
CyclicBarrier拆分成两部分来理解：
Cyclic（回环）：当所有等待线程执行完毕后，会重置状态，使其能够重用。 Barrier（屏障）：线程调用await方法就会阻塞，这个阻塞点就是屏障点，等到所有线程调用await方法后，线程就会穿过屏障继续往下执行。 相比CountDownLatch只使用一次，CyclicBarrier更强调循环使用。
@Slf4j public class CyclicBarrierTest { // 传入每次屏障之前需要等待的线程数量 private static final CyclicBarrier BARRIER = new CyclicBarrier(2, () -&amp;gt; { // 不能保证每代执行该语句的都是同一个线程 log.info(&amp;#34;doSomenthing before the last thread signal other threads&amp;#34;) }); private static final ExecutorService EXECUTOR = Executors.newFixedThreadPool(2); public static void main(String[] args) { EXECUTOR.execute(() -&amp;gt; { try { //CyclicBarrier 保证await log.info(&amp;#34;doSomething ... &amp;#34;); BARRIER.await(); log.info(&amp;#34;continue exec ...&amp;#34;); BARRIER.await(); } catch (Exception e) { e.</description>
    </item>
    
    <item>
      <title>CountDownLatch源码解析</title>
      <link>https://leejay.top/post/concurrent_count_down_latch/</link>
      <pubDate>Sat, 27 Jun 2020 18:44:37 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_count_down_latch/</guid>
      <description>CountDownLatch 描述一个或一组线程任务需要等到条件满足之后才能继续执行的场景。
常见于主线程开启多个子线程执行任务，主线程需等待所有子线程执行完毕才能继续执行的情况。
又比如车间组装产品，你必须要等到其他同事把配件组装好全交给你，你才可以最终组装。
public class CountDownLatchTest { // 显示传入计数器值 private static final CountDownLatch LATCH = new CountDownLatch(2); public static void main(String[] args) { new Thread(() -&amp;gt; { try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } // 子线程执行完毕就需要显式调用该方法 LATCH.countDown(); }).start(); new Thread(() -&amp;gt; { try { Thread.sleep(2000L); } catch (InterruptedException e) { e.printStackTrace(); } LATCH.countDown(); }).start(); System.out.println(&amp;#34;等待子线程结束任务 ...&amp;#34;); try { // 主线程阻塞直到计数器=0 LATCH.await(); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>ReadWriteLock源码解析</title>
      <link>https://leejay.top/post/concurrent_read_write_lock/</link>
      <pubDate>Wed, 24 Jun 2020 09:15:29 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_read_write_lock/</guid>
      <description>ReadWriteLock ReadWriteLock是接口，它定义了两个方法：ReadLock和WriteLock，读写锁的具体实现在ReentrantReadWriteLock中。读写锁是之前分析的独占锁和共享锁两个特性的集合体，具有如下规定：
允许多个线程同时读取变量。 某时刻只允许一个线程写变量。 如果有写线程正在执行写操作，那么禁止其他读线程读取变量。 ReadWriteLock的默认实现类ReentrantReadWriteLock
public class ReentrantReadWriteLock implements ReadWriteLock { // 读锁和写锁都是ReentrantReadWriteLock的内部类 private final ReentrantReadWriteLock.ReadLock readerLock; private final ReentrantReadWriteLock.WriteLock writerLock; final Sync sync; // 读写锁默认是非公平锁 public ReentrantReadWriteLock() { this(false); } // ReadLock和WriteLock都是继承了同一个抽象类Lock，所以他们属于同一个AQS队列 public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } } 相比于Semaphore，ReentrantReadWriteLock采用共享和独占结合的方法。Semaphore就像是一个令牌桶，谁都可以拿取令牌执行任务，谁都可以归还令牌。它不会记录是哪个线程获取了锁，而ReentrantReadWriteLock会记录，只有持有相关锁才能来释放锁。
state 与独占锁、共享锁的state的使用不同，因为需要表示两种状态，所以对int型state做了高低位切割，分别表示不同的状态。已知int=4byte= 32bit，所以高16位表示读，低16位表示写。他们的取值范围在[0 ~ 2^16 - 1]，进而我们可以得出，最多有2^16 -1个线程可以获取读锁。
abstract static class Sync extends AbstractQueuedSynchronizer { static final int SHARED_SHIFT = 16; static final int SHARED_UNIT = (1 &amp;lt;&amp;lt; SHARED_SHIFT); // 读锁和写锁的count不能超过MAX_COUNT static final int MAX_COUNT = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1; static final int EXCLUSIVE_MASK = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1; // 返回读锁的count static int sharedCount(int c) { return c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; } // 返回写锁的count static int exclusiveCount(int c) { return c &amp;amp; EXCLUSIVE_MASK; } } 读锁和写锁的count不能超过MAX_COUNT即2^16-1。</description>
    </item>
    
    <item>
      <title>Semaphore共享锁源码解析</title>
      <link>https://leejay.top/post/concurrent_semaphore/</link>
      <pubDate>Sat, 20 Jun 2020 16:09:38 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_semaphore/</guid>
      <description>acquire // 共享锁可以立即响应中断异常 public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public final void acquireSharedInterruptibly(int arg) throws InterruptedException { // 如果线程被中断立即抛出异常 if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &amp;lt; 0) doAcquireSharedInterruptibly(arg); } 共享锁tryAcquireShared()与独占锁tryAcquire()的不同在于。前者的返回值存在三种情况，后者只有两种情况(true/false)。
tryAcquireShared 值 是否获取锁 0 获取共享锁成功，后续获取可能不成功 &amp;lt; 0 获取共享锁失败 &amp;gt; 0 获取共享锁成功，后续获取可能成功 tryAcquireShared protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } // 默认是采用了非公平获取锁的方式 final int nonfairTryAcquireShared(int acquires) { for (;;) { int available = getState(); int remaining = available - acquires; // 如果remaining&amp;gt;=0时就一直自旋CAS修改state状态 if (remaining &amp;lt; 0 || compareAndSetState(available, remaining)) return remaining; } } 为什么remaining=0的时候也要尝试去修改状态，因为这个时候可能有其他线程释放了共享锁，所以有概率能获取到锁。</description>
    </item>
    
    <item>
      <title>Condition源码解析</title>
      <link>https://leejay.top/post/concurrent_condition/</link>
      <pubDate>Thu, 18 Jun 2020 20:01:58 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_condition/</guid>
      <description>Condition是一个接口，其实现在Lock内，需要配合Lock锁使用。其内部构建了一个单向队列，操作时不需要使用CAS来保证同步。
final ConditionObject newCondition() { return new ConditionObject(); } public class ConditionObject implements Condition { /** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter; public ConditionObject() { } } await // 执行await时肯定已经获取了锁，所以不需要CAS操作 public final void await() throws InterruptedException { // 如果当前线程已中断就抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); // 将当前线程添加到等待队列 Node node = addConditionWaiter(); // 线程阻塞之前必须要先释放锁，否则会死锁，这里是全部释放，包括重入锁 int savedState = fullyRelease(node); int interruptMode = 0; // 判断node是否在AQS同步队列里面，初始是在条件队列里面 while (!</description>
    </item>
    
    <item>
      <title>ReentrantLock源码解析</title>
      <link>https://leejay.top/post/concurrent_reentrant_lock/</link>
      <pubDate>Mon, 15 Jun 2020 15:53:46 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_reentrant_lock/</guid>
      <description>Lock与Synchronized都是可重入锁，否则会发生死锁。Lock锁核心在于AbstractQueueSynchronizer，又名队列同步器(简称AQS)。如果需要实现自定义锁，除了需要实现Lock接口外，还需要内部类继承Sync类。
AbstractQueueSynchronizer 记录当前锁的持有线程 由AQS的父类AbstractOwnableSynchronizer实现记录当前锁的持有线程功能（独占锁）。
state变量 内部维护了volatile修饰的state变量，state = 0时表明没有线程获取锁，state = 1时表明有一个线程获取锁，当state &amp;gt; 1时，说明该线程重入了该锁。
线程的中断 interrupt 将线程的中断标识设置为true，并不是让线程立马停止执行。 isInterrupted 判断线程的中断状态，不会对当前线程中断状态产生任何影响。 interrupted 判断当前线程的中断状态，但是会清楚当前线程的中断标识（即为false）。 线程阻塞和唤醒 由LockSupport类实现，其底层是调用了Unsafe的park 和 unpark。
如果当前线程是非中断状态，调用park则线程阻塞，如果当前线程是中断状态，调用park()会立即返回也是为什么AQS要清空中断状态的原因。 park方法不会抛出中断异常（也不会清除中断状态），如果先调用unpark再调用park，那么park也会立马返回。 连续调用多次unpark方法，效果等同于调用一次unpark方法。 park方法和sleep方法相同，不会释放资源，而wait方法会释放资源。 park方法将Runnable -&amp;gt; WAITING/TIME_WAITING，unpark方法将WAITING/TIME_WAITING -&amp;gt; Runnable。 FIFO队列 AQS内部维护了一个基于CLH(Craig, Landin, and Hagersten(CLH)locks。基于链表的公平的自旋锁)变种的FIFO双向链表阻塞队列，在等待机制上由自旋改成阻塞唤醒(park/unpark)。
还未初始化的时候，head = tail = null，之后初始化队列，往其中假如阻塞的线程时，会新建一个空的node，让head和tail都指向这个空node。之后加入被阻塞的线程对象。当head=tai时候说明队列为空。
Node的waitStatus Node状态 描述 INIT=0 Node初始创建时默认为0 CANCELLED=1 由于超时或者中断，线程获取锁的请求取消了，节点一旦变成此状态就不会再变化。 SIGNAL=-1 表示线程已经准备好了，等待资源释放去获取锁。 CONDITION=-2 表示节点处于等待队列中，等待被唤醒。 PROPAGATE=-3 只有当前线程处于SHARED情况下，该字段才会使用，用于共享锁的获取。 ReentrentLock 我们选择ReentrentLock作为入口进行源码解读，自定义的获取释放锁的方法，由其内部抽象类Sync的子类FairSync和NonfairSync中的tryAcquire、tryRelease实现。
class Test { private static final ReentrantLock LOCK = new ReentrantLock(); public void run() { LOCK.</description>
    </item>
    
    <item>
      <title>CAS乐观锁浅析</title>
      <link>https://leejay.top/post/concurrent_cas/</link>
      <pubDate>Fri, 12 Jun 2020 22:49:05 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_cas/</guid>
      <description>判断数据是否被修改，同时写回新值，这两个操作要合成一个原子操作，这就是CAS(compare and swap)。
之前多线程环境下，我们对变量进行计算都是对其加锁来实现，但是现在我们可以用过Atomic相关的类来实现相同的效果且性能更好。而AtomicInteger就是其中的一员，其底层就是通过CAS来实现的。
// 伪代码 class AtomicInteger { // 保证内存可见性 private volatile int value; public final int getAndIncrement() { for(;;) { int current = get(); int next = current + 1; // cas替换 if (compareAndSwap(current, next)) { return current; } } } public int get() { return value; } } 乐观锁：读操作不上锁，等到写操作的时候，判断数据在此期间是否被修改，如果已被修改，则重复该流程，直到把值写回去。CAS就是乐观锁的体现。
CAS的相关方法都被封装在Unsafe类中，我们以AtomicInteger中操作compareAndSwapInt()为例。
/** * var1: 这里就是AtomicInteger对象 * var2: AotmicInteger 中的成员变量，long型整数，变量在类中的内存偏移量 * 可以通过unsafe.objectFieldOffset(Field var1)来获得 * var4：变量的旧值 * var5: 变量的新值 */ public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5) Unsafe类提供了三种类型的CAS操作：int、long、Object，分别对应compareAndSwapInt()、compareAndSwapLong()、compareAndSwapObject()。</description>
    </item>
    
    <item>
      <title>volatile关键字浅析</title>
      <link>https://leejay.top/post/concurrent_volatile/</link>
      <pubDate>Mon, 08 Jun 2020 11:13:38 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_volatile/</guid>
      <description>作用 volatile保证了内存的可见性，对于共享变量操作会直接从共享内存中读取，修改时会直接将结果刷入共享内存，其次禁止了volatile修饰的变量和非volatile变量之间的重排序。
原理 为了禁止编译器重排序和CPU重排序，底层原理是通过内存屏障指令来实现的。
编译器内存屏障 只是为了告诉编译器不要对指令进行重排序，但编译完成后，这种内存屏障就消失了，CPU不会感知到编译器中内存屏障的存在。
CPU内存屏障 由CPU提供的指令(不同的CPU架构，提供的指令不同)，可以由开发者显示调用，volatile就是通过CPU内存屏障指令来实现的。
实现流程：
在volatile写操作的前面插入一个StoreStore屏障。保证volatile写操作不会和之前的写操作重排序。 在volatile写操作的后面插入一个StoreLoad屏障。保证volatile写操作不会和之后读操作重排序。 在volatile读操作后面插入一个LoadLoad屏障 + LoadStore屏障。保证volatile读操作不会和之前的读操作、写操作重排序。 与synchronized关键字的异同 多线程会产生三大问题：原子性、有序性和可见性。
synchronized和volatile在共享变量的操作上具有相同的内存语义(从主内存读取，立即写入主内存)，保证了变量的可见性。但是synchronized相比volatile还具有原子性(阻塞和排他性，同一时刻只能有一个线程执行，而volatile是非阻塞的)，所以volatile是弱化版的synchronized。
class Test { // 这里的flag就可以不用锁同步 private static volatile boolean flag = true; // 模拟AtomicInteger private static CasUnsafe UNSAFE = new CasUnsafe(0); // 按照顺序打印1-100的奇偶数 public static void main(String[] args) { THREAD_POOL.execute(() -&amp;gt; { while (UNSAFE.getValue() &amp;lt; 100) { if (flag) { System.out.println(UNSAFE.incrementAndGet()); flag = false; } } }); THREAD_POOL.execute(() -&amp;gt; { while (UNSAFE.getValue() &amp;lt; 100) { if (!</description>
    </item>
    
    <item>
      <title>MESA模型结构分析</title>
      <link>https://leejay.top/post/concurrent_mesa/</link>
      <pubDate>Sat, 06 Jun 2020 22:45:30 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_mesa/</guid>
      <description>在解释MESA模型之前，我们需要了解什么是管程：又称为监视器，它是描述并实现对共享变量的管理与操作，使其在多线程下能正确执行的一个管理策略。可以理解成临界区资源的管理策略。MESA模型是管程的一种实现策略，Java使用的就是该策略。
相关术语 enterQueue：管程的入口队列，当线程在申请进入管程中发现管程已被占用，那么就会进入该队列并阻塞。 varQueue：条件变量等待队列，在线程执行过程中(已进入管程)，条件变量不符合要求，线程被阻塞时会进入该队列。 condition variables：条件变量，存在于管程中，一般由程序赋予意义，程序通过判断条件变量执行阻塞或唤醒操作。 阻塞和唤醒：wait()和await()就是阻塞操作。notify()和notifyAll()就是唤醒操作。 模型概念图 Synchronized和Lock在MSEA监视器模型中的区别在于前者只有一个条件变量，后者可以有多个。
执行流程 多个线程进入入口等待队列enterQueue，JVM会保证只有一个线程能进入管程内部，Synchronized中进入管程的线程随机。 进入管程后通过条件变量判断当前线程是否能执行操作，如果不能跳到step3，否则跳到step4。 条件变量调用阻塞方法，将当前线程放入varQueue，等待其他线程唤醒，跳回step1。 执行相应操作，执行完毕后调用notify/notifyAll等唤醒操作，唤醒对应varQueue中的一个或多个等待线程。 被唤醒的线程会从varQueue放入enterQueue中，再次执行step1。 被唤醒的线程不会立即执行，会被放入enterQueue，等待JVM下一次选择运行，而正在运行的线程会继续执行，直到程序执行完毕。 </description>
    </item>
    
    <item>
      <title>ThreadLocal内存泄漏分析</title>
      <link>https://leejay.top/post/concurrent_thread_local/</link>
      <pubDate>Thu, 04 Jun 2020 14:49:04 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_thread_local/</guid>
      <description>ThreadLocal概述 ThreadLocal类，底层由ThreadLocalMap实现，是Thread类的成员变量，因为类的每个实例的成员变量都是这个实例独有的，所以在不同的Thread中有不同的副本，每个线程的副本只能由当前线程使用，线程间互不影响。因为一个线程可以拥有多个ThreadLocal对象，所以其内部使用ThreadLocalMap&amp;lt;ThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt;来实现。
public class Thread implements Runnable { ThreadLocal.ThreadLocalMap threadLocals = null; } public class ThreadLocal&amp;lt;T&amp;gt; { static class ThreadLocalMap { // 需要注意的是这里的Entry key是ThreadLocal的弱引用 // 弱引用的特点是当对象没有被外部强引用引用时，下次GC弱引用对象会被清理 static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; { // value 与 ThreadLocal关联 Object value; Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) { super(k); value = v; } } } } 当前线程执行时(currentThread已初始化)，会初始化ThreadLocal对象，存储在Heap堆中，ThreadLocal的引用，即ThreadLocalRef会存储在当前线程Stack栈中。 当执行ThreadLocal的get()/set()方法时，会通过当前线程的引用找到当前线程在堆中的实例，判断这个实例的成员变量：ThreadLocalMap是否已经创建(即初始化)，如果没有则初始化。 若一个Threa中存在多个ThreadLocal，那么ThreadLocalMap会存在多个Entry，Entry的key是弱引用的ThreadLocal。 内存泄漏触发条件 根据ThreadLocal堆栈示意图，我们可以推断处只要符合以下条件，ThreadLocal就会出现内存泄漏：
ThreadLocal没有被外部强引用，这样在GC的时候ThreadLocal会被回收，导致key = null。 key = null后没有调用过ThreadLocalMap中的get、set或remove方法中的任意一个。(因为这些方法会将key = null的value也置为null，便于GC回收) Thread对象没有被回收，Thread强引用着ThreadLocalMap，这样ThreadLocalMap也不会被回收。 ThreadLocalMap没有被回收，但是它的Entry中的key已被回收，key关联的value也不能被外部访问，所以导致了内存泄漏。 总结如下：
Thread生命周期还没有结束，ThreadLocal对象被回收后且没有调用过get、set或remove方法就会导致内存泄漏。
我们可以看出内存泄漏的触发条件比较苛刻的，但确实会发生，其实只要线程Thread的生命周期结束，那么Thread的ThreadLocalMap也不会存在强引用，那么ThreadLocalMap中的value最终也会被回收。，所以在使用ThreadLocal时，除了需要密切关注Thread和ThreadLocal的生命周期，还需要在每次使用完之后调用remove方法，这样做还有一个问题就是：</description>
    </item>
    
    <item>
      <title>Java内存可见性</title>
      <link>https://leejay.top/post/concurrent_memory/</link>
      <pubDate>Tue, 19 May 2020 08:08:47 +0800</pubDate>
      
      <guid>https://leejay.top/post/concurrent_memory/</guid>
      <description>CPU和JVM的重排序 CPU及JVM为了优化代码执行效率，会对代码进行重排序，其中包括：
编译器重排序(没有先后依赖关系的语句，编译器可以重新调整语句执行顺序) CPU指令重排序(让没有依赖关系的多条指令并行) CPU内存重排序(CPU有自己的缓存，指令执行顺序和写入主内存顺序不一致) 其中CPU内存重排序是导致内存可见性的主因。根据JMM内存模型，我们描述下过程：
如果线程需要修改共享变量，那么线程A会拷贝共享变量的副本到本地线程中并对其进行修改，之后会将值写回共享内存中(时间不确定)，但在写回之前，线程B读取共享变量到本地准备修改，而此时线程A修改共享变量的操作对线程B不可见。
重排序规则： as-if-serial 不管怎么重排序，单线程程序的执行结果不能被改变。只要操作之间没有数据依赖性，那么编译器和CPU都可以任意重排序。
happen-before(JVM层面) 为了明确多线程场景下那么可以重排序，哪些不可以重排序，引入了JMM内存模型，而JMM提供了happen-before规范，用于在开发者编写程序和系统运行之间效率找到平衡点，它描述了两个操作之间的内存可见性，若A happen before B，如果A在B之前执行，则A的执行结果必须对B可见。
单线程的每个操作，happen-before 于该线程中任意后续操作。 对volatile变量的写入，happen-before 于后续对这个变量的读取。 对于synchronized的解锁，happen-before于后续对这个锁的加锁。 对final域的写(构造函数中)，happen-before于对final域所在对象的读。 happen-before传递性 假设线程A先调用了set()，设置了a=5，之后线程B调用了get()，返回一定是a=5。
class Test { private int a = 0; private volatile int c = 0; void set() { a = 5;// step 1 c = 1;// step 2 } int get() { int d = c;// step 3 return a;// step 4 } } 因为step1和step2在同一块内存中，所以step1 happen-before step2，同理step3 happen before step4，且因为c是volatile变量，根据volatile变量的写 happen-before volatile变量的读，以及happen-before传递性，step1 的结果一定对step4可见。</description>
    </item>
    
    <item>
      <title>Complexity概念浅析</title>
      <link>https://leejay.top/post/algorithm_complexity/</link>
      <pubDate>Tue, 14 Apr 2020 14:41:02 +0800</pubDate>
      
      <guid>https://leejay.top/post/algorithm_complexity/</guid>
      <description>算法 算法是指用来操作数据和解决程序问题的一组方法。对于相同的问题，使用不同的算法，虽然最后的结果一致，但是消耗的时间和资源有很大的区别。
我们从时间和空间两个方面来衡量:
时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 时间复杂度 一个算法所消耗的时间，从理论上是不能算出来的，我们需要实际的测试。一个算法花费的时间与算法中语句的执行次数成正比。一个算法中语句执行次数称为语句频度或「时间频度」(记为T(n))。
在时间频度T(n)中，n为问题的规模，当n不断变化的时候，时间频度T(n)也会不断变化。我们通过引入时间复杂度(Time Complexity)的概念来体现T(n)呈现什么样的规律。
算法的时间复杂度也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称「时间复杂度」。
O(f(n))表示方法称为「 大O符号表示法 」，又称为渐进符号，是用于描述函数渐进行为的数学符号。
常见的时间复杂度量级有：
常数阶 $$ O(1) $$ 表示该算法的执行时间(或执行时占用空间)总为一个常量，不论输入数据集是大是小，只要没有循环等复杂结构，那么该代码时间复杂度就是O(1)。
int one() { int i = 1; int j = 2; return i + j; } 上述代码执行时，它消耗的时间并不会随着代码某个变量增长而增长，无论代码有多长，时间复杂度都是O(1)。
线性阶 $$ O(n) $$ 表示一个算法的性能会随着输入数据大小变化而线性变化。
void two(int n) { for (i = 1; i &amp;lt;= n; i++) { j = i; j++; } } for循环中的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，此类代码时间复杂度用O(n)表示。
平方阶 $$ O(n ^ {2}) $$ 表示一个算法的性能会随着输入数据的增长而呈现二次增长，常见于两重循环嵌套。</description>
    </item>
    
  </channel>
</rss>
