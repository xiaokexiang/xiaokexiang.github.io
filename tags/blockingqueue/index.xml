<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BlockingQueue  on Keep Improving</title>
    <link>https://leejay.top/tags/blockingqueue/</link>
    <description>Recent content in BlockingQueue  on Keep Improving</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>苏ICP备18050258号</copyright>
    <lastBuildDate>Sat, 04 Jul 2020 20:38:54 +0800</lastBuildDate><atom:link href="https://leejay.top/tags/blockingqueue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BlockingQueue单向阻塞队列源码解析</title>
      <link>https://leejay.top/post/blockingqueue/</link>
      <pubDate>Sat, 04 Jul 2020 20:38:54 +0800</pubDate>
      
      <guid>https://leejay.top/post/blockingqueue/</guid>
      <description>BlockingQueue 概念 BlockingQueue带阻塞功能的线程安全队列，但队列已满时会阻塞添加者，当队列为空时会阻塞获取者。它本身是一个接口，具体的功能由它的实现类来完成。
接口方法 public interface BlockingQueue&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt; {  // 添加元素到队列中返回boolean，队列满抛出异常  boolean add(E e);  // 添加元素到队列中，无返回值，抛出中断异常，队列满就阻塞  void put(E e) throws InterruptedException;  // 添加元素返回boolea 队列满就返回false，非阻塞  boolean offer(E e);  // 添加元素返回boolean，等待指定时间直到队列有空间可插入  boolean offer(E e, long timeout, TimeUnit unit)  throws InterruptedException; 	// 从队首获取元素并删除，阻塞，支持等待时中断异常  E take() throws InterruptedException; 	// 获取队首元素并删除，若无元素等待执行时长，时间到还没有就返回null  E poll(long timeout, TimeUnit unit)  throws InterruptedException;  // 返回理想状态下队列不阻塞可加入的元素数量，如果队列没有最大限制就返回  // Integer.</description>
    </item>
    
  </channel>
</rss>
